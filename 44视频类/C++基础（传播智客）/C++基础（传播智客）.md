### day01

#### 15、c++中的三目运算符（20200617）

+ `(a < b ? a : b) = 30; //C语言里，表达式不能做左值`
+ 在C语言中，表达式的元素结果，放在**寄存器**里，不是一个内存地址。**表达式的返回值，是一个数，是变量的值**。
+ **C++中，表达式返回的是变量的本身**。
+ 2、如何做到的？
  + **让表达式返回一个内存空间**，即内存的首地址。
  + `*(a < b ? &a : &b) = 30`
  + C语言中如何实现C++的效果
+ 3、本质
  + C++编译器 帮我们程序员完成了取地址的工作。

#### 16、const的基础和const符号表机制探究（20200618）

+ C语言里的const是个“冒牌货”，通过指针是能修改的。
+ 同样的代码，换成.cpp文件，就没法修改。C++语言中，const是一个真正的常量。
+ 两者的原因分析：
  + **C++扫描到const关键字时，不再给变量单独分配内存，而是放到符号表【是个key-value形式】里**。
  + 遇到`&`时，会再申请一个内存空间。所以修改的话，并没有修改key-value里的，而是新申请的内存空间的值。
+ 结论：
  + C语言中的const变量
    + 是只读变量，有自己的存储空间
  + C++中的const常量
    + 可能分配存储空间，也可能不分配
    + 当const常量为全局，并且需要在其它文件中使用 【这个时候才分配空间】
    + 当使用&操作符取const常量的地址 【这个时候才分配空间】

#### 17、const和#define的对比（20200620）*没有听完*

+ const分配内存的时机，编译器编译期间。

```
void main()
{
	int a;//好像 a是一个常量
	const int b = 10;
	int c;
	
	printf("%d,%d,%d",&a,&b,%c);
	system("pause");
}
```

+ const用途
  + 与#define的相同之处
  + 与#define的不同之处

### day02

#### 02、指针的引用（20200621）  *看了7min*

+ 二级指针的用法

#### 03、c++学习路线和c++基础课程学习标准（20200621）

+ **站在C++编译器的角度去看问题**
+ 1、视角问题
+ 2、具体问题
  + 1个对象的生命周期
  + 2个对象的生命周期
    + 类和类之间的关系  class A含有一个class B
  + n个对象的生命周期
    + 一族对象
  + C++面向编程思想
    + 工具、面向抽象类编程（面向接口/软件分层）

#### 05、函数参数相关扩展（20200624）

+ 两点：
  + 默认参数
  + 函数占位参数

+ **默认参数**--这个在项目中自己用得不太多，但确实很好用。
  + `void myPrint(int x = 3){}`
  + **1、若你填写参数，使用你填写的；不填就写默认**。
+ 如果有多个参数的情况下。
  + **2、在默认参数规则，如果默认参数出现，那么右边的都必须有默认参数**。
  + `void myPrint(int x = 3, int y = 4 ,int m){}//这个就会有编译错误`
  + `void myPrint(int m, int x = 3, int y = 4){}//这个没问题`
+ **函数占位参数**
  + `void func1(int a, int b, int){}`
  + **函数调用时，必须写够参数才行**。（为以后的扩展，留了个方便）
+ 默认参数和占位参数 结合使用
  + `int func2(int a, int b, int = 0){}`
  + `func2(1,2,3)`和`func(1,2)`两种调用都没有错误

#### 06、函数重载（20200624）

+ **函数重载**：函数名相同，参数个数或类型不一样。
  + **函数的返回不是函数重载的判断标准**。
+ 函数重载的调用准则
  + 精确匹配实参
  + 通过默认参数能够匹配实参
  + 通过默认参数转换匹配实参
+ 函数重载的注意事项
  + **重载函数在本质上相互独立的不同函数（静态联编）**。
+ 函数重载遇上函数默认参数
  + `int add(int a, int b,int c=0){}`
  + `int add(int a, int b){}`
  + **这里存在二义性**，编译成功，但调用时报错，因为不知道调用谁。

### day03

#### 02、构造和析构的基础知识（20200626）

+ 前言
  + **对象的初始化工作**。（类的数据成员是不能在声明类时初始化的）。**构造函数**（不需要用户调用，在建立对象时自动执行）。
+ 有关构造函数
  + 构造函数与类名相同
  + 构造函数在定义时可以有参数
  + 没有任何返回类型的声明
+ 构造函数的调用
  + 自动调用：一般情况下C++编译器会自动调用构造函数。
  + **手动调用**：在一些情况下则需要手工调用构造函数
+ 有关析构函数
  + 特殊的成员函数清理对象
  + `~className`
  + 析构函数没有参数，也没有任何返回类型的声明
  + 析构函数在对象销毁时自动被调用
+ 析构函数调用
  + C++编译器自动调用
+ 也可以在`VASSISTX`->`Tools`->`edit VA Snippet Editor`里添加了一个`#2`，我原来用的是VS自带的，快捷键是`cppmain`
+ **先创建的对象，后释放**

#### 03、构造和析构的用途演示（20200626）

+ `#define _CRT_SECURE_NO_WARNINGS`，用于屏蔽部分告警。
+ **对于自己定义的指针类型，要在构造函数里手动申请，同时析构函数里手动释放**

#### 04、构造函数的调用(无参数和有参构造)  （20200626）

+ 无参构造函数
+ 带参数的构造函数
+ 拷贝构造函数（赋值构造函数）
  + `Test2(const Test2& obj) `
+ 调用构造函数的3种方法
  + 1、括号法`Test2 t0402(3);`
  + 2、等号法`Test2 t0402=(3);//警惕 逗号表达式的陷阱`
  + 3、直接调用构造函数`Test2 t0404 = Test2(1, 2);//会产生一个匿名对象，**要注意生存期的问题**`

#### 05、课堂答疑对象的初始化和对象的赋值是两个不同的概念（20200626） 

+   `Test2 t0404 = Test2(1, 2);//初始化`
+ `t0401 = t0404;//赋值`
+ *具体两个不同*--自己在脑子里再想想

#### 06、为什么需要构造和析构函数（20200626）

+ **类Test只是一个类型**，C++编译器会自动调用，我们写的构造函数。
+ 构造函数的调用方法是：
  + 自动调用（【隐式调用】按照规则调用）
  + 也可以显式地初始化类的属性或其它资源。
+ **为每个类都提供一个public的initialize函数**
  +   initialize只是一个普通的函数，必须显式地调用
  + 一旦由于失误的原因，对象没有初始化，那么结果是不确的。
  + 不能完全解决问题。 
  + *对象数组就没办法使用这个方法了？*--lionel，要写个例子看下呢。
+ **如果你定义的类没有写构造函数，C++编译器会给你安排一个默认构造函数。**

#### 07、copy构造函数的调用时机1和2（20200626）

+ 有4种场景
+ **赋值构造函数**：用1个对象去初始化另外一个对象。
  + 第1种方法：`Test7 t2 = t1;`
  + 第2种方法：`Test7 t2(t1);`

#### 08、课堂答疑（20200626）

+ 拷贝构造函数也是**构造函数**
+ **赋值操作`=`，不会调用构造函数**。

#### 09、copy构造函数调用时机3（20200626）

+ **函数调用时，会执行实参变量初始化形参变量**
+ 赋值构造函数（拷贝构造函数）的样子
  + `Test4(const Test4& obj)`

#### 10、copy构造函数调用时机4_函数返回值是匿名对象（20200626）

+ 1、若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构。
+ 2、若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象

#### 11、copy构造函数调用时机4_函数返回值是匿名对象的去和留的剖析（20200627）

+ 结论1：函数的返回值是一个元素（复杂类型的）。【C++编译器，就这么设计的】，A是临时对象，返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数)
+ 结论2：有关匿名对象的去和留
  + 如果用匿名对象初始化另外一个同类型的对象，那么匿名对象直接转成有名对象
  + 如果用匿名对象 赋值给 另外一个同类型的对象，匿名对象 马上被析构

#### 12、构造和析构的重点整理（20200627）

+ *整理了两张图*

#### 13、构造和析构总结（20200627）

+ **这个要好好看看**，能串起来知识点。

#### 15、构造函数的调用规则研究（20200627）

+ *看图片*
+ **只要你写了构造函数，那么你必须要用**。 （在定义类时，只要你写了构造函数【不管是有参构造函数，还是拷贝构造函数】，则必须要用。）

#### 16、浅拷贝问题抛出（20200628）

+ **必要的时候，必须手工编写拷贝构造函数**。 

#### 17、浅拷贝问题分析（20200628）

+ *全局区的数据不要忘了*
+ **浅拷贝**，只是拷贝了值，没有在堆区开辟空间，相当于两个指针，指向了同一个内存地址。
+ *画了个图*，同时还给了个指针的铁律。

#### 18、浅拷贝问题解决 深拷贝 显式编写拷贝构造函数（20200628）

+ **`private`变量，最好用`m_`开头**。

#### 19、深拷贝和浅拷贝 默认的等号操作符也是浅拷贝（20200628）

+ `obj3 = obj1;//这个情况，不是初始化`，**要显式重载`=`操作符**。

#### 20、构造函数的初始化列表（20200704）

+ Q1：*构造函数的初始化列表*解决了啥问题？
+ 调用顺序：
  + 先执行 被组合对象的构造函数（如果组合对象有多个，按照定义顺序，而不是按照初始化列表的顺序）
+ 被组合对象的构造顺序 与定义顺序有关系，与初始化列表的顺序没有关系

#### 21、强化训练1：构造和析构调用顺序（20200704）

+ 构造析构练习强化.cpp
  + 展示分析过程，注意赋值构造函数的调用

#### 22、强化训练2：匿名对象生命周期（20200705）

#### 23、强化训练3：构造中调用构造(产生匿名对象)  （20200705）

+ **在构造函数中调用构造函数是个危险的操作**。

#### 24、new和delete的基本语法（20200705）

+ `new int;` 开辟一个存放整数的存储空间，返回地址
+ `new int(100);` 开辟一个存放整数的存储空间，并指定该整数的初值是100，返回地址
+ `new char[10];`开辟一个存放字符数组的空间，返回首元素的地址
  + `delete []p`
+ **虽然new和malloc都能分配空间，但new可以自动调用类写的构造函数，同理，delete会调用析构函数**。

#### 25_new和delete的深入分析

#### 26_静态成员变量和静态成员函数

#### 27_C++面向对象模型初探_传智扫地僧

#### 28_this指针

#### 29_作业

### day04

#### 02、const修饰的是谁（20200709）

+ 1、const写在什么位置 没有关系
  + `const void OpVar(int a, int b)`
  + `	void OpVar(int a, int b) const`
+ 2、const修改的是this指针。
  + **因为 `this指针`被隐藏了，没办法写在里面，所以就写在前后都没关系了**
  + `void OpVar(const Test *this, int a, int b)`
+ **要把细节抠得相当细**。

#### 03、this的const修饰课堂答疑（）

#### 04、全局函数pk成员函数（返回元素，引用，星号this）（20200710）

+ **全局函数和成员函数转换的问题**。
  + `Test add(Test &t1, Test &t2)==>Test add(Test &t2)`，**通过this指针隐藏左操作数**（全局转化为成员）
  + `void printAB() ==> void printAB(Test *pthis)`，**多了一个参数**（成员函数转化为全局）
+ 函数返回元素和返回引用
  + `return *this`
+ *看到16min（共22min）*

### day07

#### 02、多态原理探究（20200615）

+ 多态成立的3个条件
  + 1、要有继承
  + 2、要有虚函数重写
  + 3、要有父类指针指向子类对象
+ C++编译器根本不需要区分是子类对象，还是父类对象，**父类对象和子类对象分别都有vptr指针，去虚函数表找函数的入口地址**，实现了迟绑定，只有在运行时才进行判断。

#### 03、证明vptr指针的存在（20200615）

#### 04、子类的vptr指针是分步初始化的（20200616）

+ 构造函数中调用虚函数能发生多态吗？【**不能发生**】
+ `Child c1`
  + 1、要初始化c1.vptr指针，初始化是分步的
  + 2、当执行父类的构造函数时，c1.vptr指向父类的虚函数表；当父类的构造函数运行完毕后，会把c1.vptr指针指向子类的虚函数表。
  + 结论：子类的c1.vptr指针分步完成。

#### 05、面试题强化

