### day01

#### 15、c++中的三目运算符（20200617）

+ `(a < b ? a : b) = 30; //C语言里，表达式不能做左值`
+ 在C语言中，表达式的元素结果，放在**寄存器**里，不是一个内存地址。**表达式的返回值，是一个数，是变量的值**。
+ **C++中，表达式返回的是变量的本身**。
+ 2、如何做到的？
  + **让表达式返回一个内存空间**，即内存的首地址。
  + `*(a < b ? &a : &b) = 30`
  + C语言中如何实现C++的效果
+ 3、本质
  + C++编译器 帮我们程序员完成了取地址的工作。

#### 16、const的基础和const符号表机制探究（20200618）

+ C语言里的const是个“冒牌货”，通过指针是能修改的。
+ 同样的代码，换成.cpp文件，就没法修改。C++语言中，const是一个真正的常量。
+ 两者的原因分析：
  + **C++扫描到const关键字时，不再给变量单独分配内存，而是放到符号表【是个key-value形式】里**。
  + 遇到`&`时，会再申请一个内存空间。所以修改的话，并没有修改key-value里的，而是新申请的内存空间的值。
+ 结论：
  + C语言中的const变量
    + 是只读变量，有自己的存储空间
  + C++中的const常量
    + 可能分配存储空间，也可能不分配
    + 当const常量为全局，并且需要在其它文件中使用 【这个时候才分配空间】
    + 当使用&操作符取const常量的地址 【这个时候才分配空间】

#### 17、const和#define的对比（20200620）*没有听完*

+ const分配内存的时机，编译器编译期间。

```
void main()
{
	int a;//好像 a是一个常量
	const int b = 10;
	int c;
	
	printf("%d,%d,%d",&a,&b,%c);
	system("pause");
}
```

+ const用途
  + 与#define的相同之处
  + 与#define的不同之处

### day02

#### 02、指针的引用（20200621）  *看了7min*

+ 二级指针的用法

#### 03、c++学习路线和c++基础课程学习标准（20200621）

+ **站在C++编译器的角度去看问题**
+ 1、视角问题
+ 2、具体问题
  + 1个对象的生命周期
  + 2个对象的生命周期
    + 类和类之间的关系  class A含有一个class B
  + n个对象的生命周期
    + 一族对象
  + C++面向编程思想
    + 工具、面向抽象类编程（面向接口/软件分层）

### day07

#### 02、多态原理探究（20200615）

+ 多态成立的3个条件
  + 1、要有继承
  + 2、要有虚函数重写
  + 3、要有父类指针指向子类对象
+ C++编译器根本不需要区分是子类对象，还是父类对象，**父类对象和子类对象分别都有vptr指针，去虚函数表找函数的入口地址**，实现了迟绑定，只有在运行时才进行判断。

#### 03、证明vptr指针的存在（20200615）

#### 04、子类的vptr指针是分步初始化的（20200616）

+ 构造函数中调用虚函数能发生多态吗？【**不能发生**】
+ `Child c1`
  + 1、要初始化c1.vptr指针，初始化是分步的
  + 2、当执行父类的构造函数时，c1.vptr指向父类的虚函数表；当父类的构造函数运行完毕后，会把c1.vptr指针指向子类的虚函数表。
  + 结论：子类的c1.vptr指针分步完成。

#### 05、面试题强化

