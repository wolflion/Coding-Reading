## 内容

### day10、网络编程基础socket

#### 01、知识点概述（20200401）

+ 第8-10天，自己实现一个Mini Web服务器（有两个功能）
  + 处理网络I/O
  + 业务处理

#### 02、网络开发两种设计模式（）

+ 

#### 03、网络模型分层（）

+ 

#### 04、以太网帧协议（）

+ 

#### 05、IP协议（）

+ 

#### 06、UDP协议（）

+ 

#### 07、TCP协议（）

+ 

#### 08、TCP-IP四层模型协议封装（）

+ 

#### 09、UDP和TCP讲解（）

+ 

#### 10、什么是套接字（20200401）

+ **Socket是网络通信的函数接口的总称**，封装了传输层的协议（TCP，UDP）。
+ 浏览器，应用层用的是HTTP，往下封装的是TCP。
+ Socket：IP+Port。

#### 11、套接字内存模型（20200401）

+ socket通信
  + 服务器端（插座）**被动**让客户端连接；
  + 客户端（电风扇、电视）**主动**
+ socket编程--**网络IO编程**
  + 读写操作（read/wirte)
    + 文件描述符
  + 创建一个套接字，得到的是文件描述符，**这个fd也是一块内核缓冲区**
  + **内核缓冲区分为两部分（读缓冲区，写缓冲区）**，这是系统处理好的，不用应用程序关心。
  + 客户端的数据先write到写缓冲区，然后会到同步到服务端的读缓冲区里，服务端fd里的写缓冲区也一样。
  + *与匿名管道的区别？*
  + **默认是阻塞的**，对应的是fd的设备的文件性质，不是wirte(),read()函数的性质。
+ 匿名管道
  + 分为读、写两端  **队列**数据结构
  + 管道的读写两端分别对应一个文件描述符
  + 内核缓冲区（内存中一块存储空间）
  + **默认是阻塞的**

#### 12、知识点复习（）

+ 

#### 13、大端和小端存储（）

+ 

#### 14、大小端转换函数

### day11、TCP三次握手-并发

#### 1、学习目标

#### 2、知识点回顾（）

+ 

#### 3、tcp客户端代码实现（）

+ 

#### 4、socket函数封装（）

+ 

#### 5、父子进程实现ps-grep命令（20200322）

+ 实现`ps aux|grep bash`功能

#### 6、ps-grep命令实现问题解决（20200322）

+ `grep bash`这种是匹配标准输入；`grep "bash"`也是一样滴
+ **父进程认为还有写端存在，就有可能还有人给发数据，继续等待**，保证同一个流向，读端读，写端关闭即可。
+ **要保证数据流向没有岔路**。

#### 07、管道的读写行为（20200323）

+ 读管道
  + 写端全部关闭--read读到0，相当于读到文件尾
  + 写端没有全部关闭
    + 有数据--read读到数据
    + 没有数据--read阻塞，**fcntl函数可以更改非阻塞**
+ 写管道
  + 读端全部关闭--产生一个信号SIGPIPE，程序异常终止
  + 写端没有全部关闭
    + 管道已满--write阻塞（读端一直不读；写端狂写）
    + 管道未满--write正常写入

#### 08、管道大小和优劣（20200323）

+ `ulimit -a`里的pipe大小，或者用`fpathconf()`函数来查看大小
+ 优点：
  + 简单
+ 缺点：
  + 只能有血缘关系的进程通信
  + 父子进程单向通信，如果需要双向通信，需要创建多根管道
+ **实现兄弟进程间通信**  `ps aux | grep bash`

#### 09、

#### 10、fifo实现通信写端（20200323）

+ FIFO有名管道，实现无血缘关系进程通信
  + **创建一个管道的伪文件**
+ `mkfifo`命令，**创建伪文件**，也可以是`mkfifo()`函数
+ 内核会针对fifo文件开辟一个缓冲区，操作fifo文件，可以操作缓冲区，实现进程间通信--**实际上就是文件读写**。

#### 11、fifo使用注意事项（20200324）

+ [fifo_r.c]
  + **open()阻塞了**，用`FIFOs`会被卡住。
+ open注意事项：
  + 打开fifo文件的时候，read端会阻塞等待write端open，write端同理，也会阻塞等待另外一端打开。

#### 12、上午内容回顾

#### 13、多线程版客户端代码实现（）

+ 



### day12、TCP状态转换-select

#### 01、内容复习

#### 02、作业说明

#### 03、信号的回顾（20200308）

+ **杀死进程，就是通过信号来产生，信号是内核产生和处理的**。
+ 信号四要素：
  + 编号
  + 名称
  + 事件
  + 默认处理动作（Term，Ign， Core，Stop，Cont）。 `man 7 signal` 终止，忽略，终止产生Core，暂停，继续
+ 信号的特点：
  + 简单
  + 不能携带大量信息
  + 特定条件下产生
+ **信号也叫软件产生的中断，有可能会有延迟**。
+ 信号的处理方式：
  + 执行默认动作（上面的5个）
  + 忽略
  + 捕捉
+ **9，19号信号不能捕捉，不能忽略，甚至不能阻塞**。

#### 04、学习目标（20200308）

+ 信号的基本概念
+ 信号相关的函数，信号集操作相关函数
+ **熟练掌握**信号捕捉函数signal()和sigaction()
+ **熟练掌握**使用信号完成子进程的回收。
  + *加上wait()，子进程退出的时候回收回来，不用傻等了*。--这个不是太熟悉，要学习一下。lionel。

#### 05、阻塞信号集，未决信号集信号产生（20200308）

+ **递达**：递送并且到达进程。
+ **未决**：产生和递达之间的状态。主要由于阻塞（屏蔽）导致该状态。
+ 集合理解为位图，**最大的就是31，从1号开始**，0号信号有特殊含义。
+ **未决信号集**：来了之后先把信号置为1，信号处理之后置为0。
+ **阻塞信号集**，用于影响**未决信号集**，一直阻塞的话，一直未决。
+ 信号的产生
  + 终端按键：`ctrl+C`
  + 硬件异常：非法内存访问
  + kill函数/命令产生信号：
  + 系统API产生信号：`int kill(pid_t pid, int sig);`
    + pid大于0，要发送的进程ID
    + pid等于0，代表当前调用进程组内所有进程
    + pid等于-1，代表有权限发送的所有进程
    + pid小于0，代表-pid对应的组内所有进程
    + sig对应的信号
+ **练习**：某个子进程把父进程杀死
  + [killfather.c]

#### 06、raise和abort（20200309）

+ [kill3.c]
+ `int raise(int sig)`自己给自己发送信号。
+ `abort()`自己给自己发一个SIGABRT的信号。
+ [raise_abort.c]

#### 07、alarm发送信号（20200309）

+ alarm
  + 定时给自己发送SIGALRM
  + 几秒后发送信号
  + 返回值：上次闹钟剩余的描述
  + 特别的，如果传入参数秒为0，代表取消闹钟

#### 08、setitimer使用（20200310）

+ 周期性的发送信号。
+ 原型
  + new_value 要设置的闹钟时间
  + old_value 原闹钟时间
+ **which的3种值，对应不同的处理信号**。
  + ITIMER_REAL，自然定时法，SIGALRM
  + ITIMER_VIRTUAL 计算进程执行时间 SIGVTALRM
  + ITIMER_PROF  进程执行时间+调度时间
+ [setitimer.c]
+ [setitimer2.c]

#### 09、setitimer实现alarm前（20200310）

+ [myalarm.c]

#### 10、setitimer实现alram后（20200310）

+ 接上面[myalarm.c]

#### 11、1秒数数（20200310）

+ [count.c]
+ 用`time ./a.out`来计算。
+ 用`time ./a.out >1.log`来看区别。`tail -f 1.log`
+ printf比1.log慢的原因；**printf是行缓冲的，重定向是字节缓冲**。

#### 12、上午内容回顾

#### 13、信号集的函数（20200311）

+ **信号集**：
+ `sigemptyset()`：清空set，变为0。
+ `sigfillset()`：填充set，变为1。
+ `sigaddset()`：添加某个信号到信号集
+ `sigdelset()`：从信号集中删除某个信号（变为0）
  + 以上return0表示成功。
+ `sigismemeber()`：是否为集合里的成员
  + 返回1代表signum在集合中。
+ 设置阻塞或解决阻塞信号集：`sigpromask()`
  + how
    + SIG_BLOCK：设置阻塞
    + SIG_UNBLOCK：解除阻塞
    + SIG_SETMASK：设置set为新的阻塞信号集
  + set传入的信号集
    + 上面的几个函数
  + oldset：旧的信号集，传出（便于恢复之前的状态）
+ 读取当前的未决信号集：`sigpending()`

#### 14、打印未决信号集（20200311）

+ 打印当前信号集的打印[sigpending.c]

#### 15、sigaction捕捉settimer产生信号（20200312）

+ 作用：
  + 防止进程意外死亡。
+ `signal()`--尽量避免使用
  + signum：要捕捉的信号
  + handler：要执行的捕捉函数指针，**函数应该声明void func(int);**。
+ `sigaction()`
  + signum：捕捉的信号
  + act：传入的动作  是个结构体`struct sigaction{};`
    + (*sa_handler)(int) //函数指针，**一般flag是0时**
    + (*sa_sigaction)//flag非0时，使用
    + sa_mask//执行捕捉函数期间，临时屏蔽的信号集
    + sa_flags; //一般填0 **SA_SIGINFO会使用第2个函数指针**
    + (*sa_restorer)(void);//无效
  + oldact：原动作，用于恢复现场
  + 返回值：成功返回0，失败返回-1
+ [sigaction.c]

#### 16、sigaction特性演示（20200312）

+ 默认PCB中有一个信号屏蔽字，信号捕捉期间是由sa_mask来决定。
+ XX信号捕捉函数执行期间，XX信号自动被屏蔽。
+ 阻塞的常规信号，产生多次只记录一次。
+ [sigaction_mask.c]

#### 17、信号的处理流程（20200309）

+ 用户状态：发生中断、异常
+ 内核状态：处理以上导演，定义了捕捉函数，就回到用户状态，然后通过`sys_sigreturn()`再回到内核态。

#### 18、利用SIGCHLD回收子进程（20200313）

+ 子进程在暂停或退出的时候会发送SIGCHLD信号，我们可以通过捕捉SIGCHLD信号来回收子进程，这样就不用等待`wait()`了。
+ [child_catch.c]

#### 19、SIGCHLD回收注意事项（20200313）

+ [child_catch.c] 接上，*这个最好能写个01，02这样的序列*。

#### 20、总结和作业



### day13、epoll-UDP

#### 01、内容回顾

#### 02、守护进程相关的概念（20200314）

+ **创建“进程组”，“会话”的概念，主要是便于管理**。

+ 进程组：
  + 1个父进程创建5个子进程，父进程就是进程组的组长。
  + 多个进程在同一个组，第一个进程默认是组长。
+ 会话：
  + 含有多个进程组。
  + **组长不可以创建创建会话，必须是组员创建**。
  + 注意事项：
    + 调用进程不能是进程组组长，该进程变成新会话首进程（session header）
    + 该进程成为一个新进程组的组长进程
    + 新会话丢弃原有的控制终端，该会话没有控制终端
    + 该调用进程是组长进程，则出错返回
    + 建立新会话时，先调用fork，父进程终止，子进程调用setsid。
+ **创建会话的步骤：**
  + 创建子进程，父进程去死，子进程自当会长。
+ `getsid()`和`setsid()`中的s表示session。
+ 守护进程
  + **与终端无关**，终端关闭，进程依然存在。
  + **原理就是**SIGHUP，通过1号信号来关闭相关进程。
  + **以d结尾的进程**，是守护进程，比如`systemd`，如果是`?`代表与终端无关。
  + **创建守护进程，最关键的一步是调用setsid函数创建一个新的session，并成为session Leader**。
+ **创建守护进程模型**
  + 1、创建子进程，父进程退出
  + 2、在子进程中创建新会话
  + 3、改变当前目录为根目录 （非必须），根目录没权限，用`$HOME`
  + 4、重设文件权限掩码（非必须），`umask`命令，当前进程的掩码
  + 5、关闭文件描述符（非必须），为了避免浪费资源
  + 6、开始执行守护进程核心工作
  + 7、守护进程退出处理程序模型（**一般不退出**）
  + **调试的时候，先不要杀死父进程，先用父进程执行核心工作，逻辑没问题了，再执行创建子进程，杀死父进程**。

#### 03、守护进程创建（20200314）

+ 创建一个守护进程（作业）：每分钟在$HOME/log/创建一个文件，程序名.时间戳

#### 04、守护进程扩展了解（20200314）

+ `nohup`可以阻塞1号进程。 即`nohup ./a.out &`  //&表示后台运行，SIGHUP
+ **通过nohup指令也可以达到守护进程创建的效果**。会让cmd收不到SIGHUP信号。

#### 05、线程有关的概念（20200315）

+ **线程**：轻量级的进程，本质仍是进程（在Linux下）
+ 进程：独立地址空间，有PCB
  + 一个进程默认就是一个线程，但可以有多个线程。**相当于合租**
+ 线程：有PCB，**没有独立的地址空间**。【线程就执行一个函数，所以就在stack上不共享。】
+ **Linux下：线程（最小的执行单位）；进程（最小分配资源单位，可看作只有一个线程的进程）**。
+ **进程是苦力，是真正干活的**。（车间是个进程的话；车间的员工就是线程）。
+ 1个CPU只有1核的话，多线程有没有用？**没有用，因为只有1个线程获得CPU**.
+ **内核实现都是通过clone函数实现的，所以从内核看没有区别**。线程所有操作函数pthread*是库函数，而非系统调用。
+ 多线程和多进程其实区别不大，**多线程通讯时节省了很多成本**，类unix系统早期没有线程的概念，引入自windows。【windows里玩得比较6】
+ 查看lwp号：`ps -Lf pid`

#### 06、线程的优点和缺点（20200315）

+ 线程共享资源
  + 文件描述符表
  + 每种信号的处理方式
  + 当前工作目录
  + 用户ID和组ID
  + 内存地址空间（.text/.data/.bss/heap/共享库）
+ **尽量不要信号和多线程一起使**，因为其中任何一个都已经很乱了。
+ 线程非共享资源
  + 线程Id
  + 处理器现场和栈指针（内核栈）
  + 独立的栈空间（用户空间栈）
  + errno变量
    + 用`perror()`不行了，**线程里要用`strerror()`才行**。
  + 信号屏蔽字
  + 调度优先级
+ 线程优、缺点
  + 优点： 提高程序并发性；占用资源小，开销小；数据通信、共享数据方便
  + 缺点：库函数，不稳定；调试、编写困难；对信号支持不友好
  + 优点相对突出，缺点均不是硬伤。**Linux下由于实现方法，导致进程、线程差别不是很大**。
+ 引入多线程的目的：**为了更好的使用CPU**。

#### 07、创建一个线程（20200315）

+  **pthread_开头的函数**，以`pthread_create()`为例，**编译和链接时要加上-lpthread**。
  + thread：线程id，传出参数
  + attr：线程的属性 **大多数时候不用**
  + 第三个参数 函数指针 void* func(void*)
  + arg：线程执行函数的参数
  + 返回值：成功返回0；失败返回errno。
+ **线程是个库函数，要加pthread**.
+ **`pthread_self()`用于获取当前线程id。**
+ `set -o vi` **快捷查找之前的命令**。 [关于set -o vi的使用](https://blog.csdn.net/cnsdlywei/article/details/81906730) --设置shell里vi的快捷键。
  + 设置后的vi的快捷键在shell中使用 
+ 在$HOME的.bashrc增加
  + `alias echomake='cat ~/bin/makefile.template>>makefile'`

#### 08、线程的退出（20200316）

+ [pthread_exit.c]
  + **这个地方只是退了，但没有看到返回值**，具体要一节代码展现。
+ 线程退出函数，线程退出注意事项
  + 在线程中使用pthread_exit
  + 在线程中使用return（**主控线程return代表退出进程**）
  + **exit代表退出整个进程**。
+ **关注一下pthread_exit()的参数**。

#### 09、线程的回收（20200316）

+ [pthread_rtn.c]
+ 不回收，就会变成**僵尸线程**。
+ `pthread_join()`
  + thread：创建的时候传出的第一个参数
  + retval：代表的传出线程的退出信息（代码中的return值）
+ **线程回收，也是阻塞等待回收**

#### 10、上午内容的回顾

#### 11、杀死线程（20200316）

+ [pthread_cancel.c]
+ `pthread_cancel()`参数是pthread_t
  + **线程是被取消的话，退出值就是-1**，因为`#define PTHREAD_CANCELD((void*)-1)`
  + 失败返回errno，成功返回0。
+ **如何没有cancel point的话，就没法杀死线程**。用`pthread_testcancel()`来强行设置取消点。

#### 12、线程分离（20200317）

+ **好处**：线程回收就不用自己管了，不需要用`pthread_join()`回收资源了。
+ `pthread_deatch(pthread_t thread)`

#### 13、线程属性设置分离（20200319）

+ [pthread_var.c]
  + **全局变量**
+ `pthread_equal()`判断两个线程是否相等
  + **在某个进程内是唯一的，但整个系统中并不是唯一的**。
+ [npthread.c]**创建多个线程**
+ **线程的分离状态（掌握）**
  + `pthread_attr_setdetachstate()`
    + attr init初始化的属性
    + detachstate的值
      + PTHREAD_CREATE_DETACHED **线程分离**
      + PTHREAD_CREATE_JOINABLE  **允许回收**
  + 初始化`pthread_attr_init()`
  + 销毁`pthread_attr_destory()`

#### 14、线程注意事项（20200320）

+ NPTL
  + `getconf GNU_LIBPTHREAD_VERSION`查看pthread版本
  + NPTL实现机制（posix）**Native POSIX Thread Library**
  + gcc指定 -lpthread
+ 线程使用注意事项
  + 主线程退出其它线程不退出，主线程应调用`pthread_exit`，return退出会进程退出。
  + 避免僵尸线程
    + pthread_detach
    + pthread_join
    + pthread_create指定分离属性
  + malloc和mmap申请的内存可以被其它线程释放（必然的，因为它们是共享的）
+ 创建多少个线程合适
  + **CPU核数 double一下后，再加2**

#### 15、总结和作业

#### 16、线程同步的概念（20200321）

+ （银行卡，存折）对应同一个账户；不同的人对分别（银行卡，存折）的操作，**得有先后顺序**，不然余额就乱了。
+ 同步概念
  + 数据库同步：两个或多个数据库内容保持一致
  + 文件同步：两个或多个文件夹里的文件保持一致
  + 编程中，**“同”**指协同、协助，互相配合。
+ 线程同步：
  + **同步即协同步调，按预定的先后次序运行**。
  + 一个线程发出某一功能调用时，在没有得到结果前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。
+ **解决同步的问题：加锁！**
+ 数据混乱原因：
  + 资源共享
  + 调度随机（意味着数据访问会出现竞争）
  + 线程间缺乏必要的同步机制**只能解决第3点**。

#### 17、mutex相关的函数（20200321）

+ [thr_write.c] *这个自己就没写*
+ `pthread_mutex_`开头的函数
+ `pthread_mutex_init`
  + `pthread_mutex_t *restrict`，**restrict约束该块内存区域对应的数据，只能通过后面的变量进行访问和修改**。
  + `pthread_mutexattr_`开头，**这个用不着**，传`NULL`即可。
+ **mutex是互斥量** -- 锁。
+ `pthread_mutex_lock()` 给共享资源加锁
  + mutex init初始化的锁
  + 如果未所，成功，给线程加锁；
  + 如果已锁，**阻塞等待**。
+ `pthread_mutex_destroy()` 摧毁锁
  + mutex 传入的锁
+ pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; **常量初始化**，可以不用`init`。

### day14、广播-组播-本地套接字

#### 01、内容回顾

#### 02、学习目标

#### 03、互斥量的使用（20200329）

+ `pthread_mutex_开头的函数`
+ 互斥量的使用频繁：
  + 初始化
  + 加锁
  + 执行逻辑---操作共享数据
  + 释放锁
+ 注意事项：**加锁需要最小粒度，不要一直占用临界区**。
+ `pthread_mutex_trylock()`
+ [mutex_trylock.c]
  + **错误码的头文件`/usr/include/asm-generic/errno-bash.h`**

#### 04、死锁（20200329）

+ 锁了又锁（锁了2次）
  + 自己加了一次锁成功，又加了一次。
+ **交叉锁**（自己抢占了一个，又抢占对方的）
  + 解决办法：**每个线程申请锁的顺序要固定（或一致）*
  + 如果申请到一把锁，申请另外一把锁的时候申请失败，应该释放已经掌握的。
+ **互斥锁只是建议锁**，防君子不防小人。

#### 05、读写锁（20200329）

+ 与互斥量类似，但读写锁允许更高的并发性。其特性为：**写独占，读共享**。
+ **读的写的时候不改变数据，不用加锁，只有写的时候，才加锁**。
+ 读写锁特性：
  + **写的优先级高**
  + 多个读的时候才共享，但凡有写的时候需要锁
+ `pthread_rwlock_init()`
+ **读写锁只有一把**，有不同的状态
  + 未加锁
  + 读锁（读模式下加锁）
  + 写锁（写模式下加锁）
+ 读写锁场景练习：
  + 线程A写锁成功，线程B请求读锁
    + 线程B阻塞
+ *学到第5分钟*

#### 06、条件变量介绍和生产者和消费者模型（20200331）

+ 因为竞争后，抢到了后发现里面资源自己用不了，所以引入**条件变量**。
+ 条件变量，本身不是锁，但可以引起阻塞。**竞争者可以阻塞在条件变量上**。
+ `pthread_cond_init()` **条件变量**相关的函数，初始化
+ `pthread_cond_timedwait()` **超时等待**中的
  + abstime：**直接在struct timespec**上加时间即可。`time(NULL)+600`==>设置超时600s。
+ `pthread_cond_wait()` 条件变量阻塞等待
+ **条件变量不是锁，要和互斥量组合使用**。
  + 先拥有锁，释放锁，阻塞在条件变量上。
+ `pthread_cond_destory()`销毁一个条件变量
+  **唤醒至少一个阻塞在条件变量cond上的线程**。`pthread_cond_singal()`
+ 唤醒在条件变量上的所有线程：`pthread_cond_broadcast()`

#### 07、上午内容回顾

#### 08、条件变量生产者消费者模型实现（20200331）

+ **条件变量的作用**：避免没有必要的竞争。
+ [cond_produce.c]

#### 09、条件变量生产者消费者模型演示

#### 10、信号量的概念（20200331）

+ **信号量--加强版的互斥锁**。允许多个线程访问共享资源。
  + mutex_lock，就是mutex--
  + mutex_unlock，就是mutex++
+ `sem_init()`
  + sem定义的信号量，传出
  + pshared：
    + 0代表线程信号量
    + 非0代表进程信号量
  + value：允许的并发数
+ 摧毁信号量`sem_destory()`
+ 申请信号量，申请成功，value--，当信号量为0时，阻塞`sem_wait()`
+ `sem_post()`释放信号量，value++
+ `sem_wait`相当于--，`sem_post`相当于++
+ **编译的时候，必须要加上pthread**。

#### 11、信号量实现生产者和消费者分析

#### 12、信号量实现生产者和消费者

#### 13、文件锁单开进程

#### 14、哲学家就餐模型

#### 15、总结

### day15、libevent

### day16、xml json

