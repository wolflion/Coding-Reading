## 内容

### day10、网络编程基础socket

#### 01、知识点概述（20200401）

+ 第8-10天，自己实现一个Mini Web服务器（有两个功能）
  + 处理网络I/O
  + 业务处理

#### 02、网络开发两种设计模式（）

+ 

#### 03、网络模型分层（）

+ 

#### 04、以太网帧协议（）

+ 

#### 05、IP协议（）

+ 

#### 06、UDP协议（）

+ 

#### 07、TCP协议（）

+ 

#### 08、TCP-IP四层模型协议封装（）

+ 

#### 09、UDP和TCP讲解（）

+ 

#### 10、什么是套接字（20200401）

+ **Socket是网络通信的函数接口的总称**，封装了传输层的协议（TCP，UDP）。
+ 浏览器，应用层用的是HTTP，往下封装的是TCP。
+ Socket：IP+Port。

#### 11、套接字内存模型（20200401）

+ socket通信
  + 服务器端（插座）**被动**让客户端连接；
  + 客户端（电风扇、电视）**主动**
+ socket编程--**网络IO编程**
  + 读写操作（read/wirte)
    + 文件描述符
  + 创建一个套接字，得到的是文件描述符，**这个fd也是一块内核缓冲区**
  + **内核缓冲区分为两部分（读缓冲区，写缓冲区）**，这是系统处理好的，不用应用程序关心。
  + 客户端的数据先write到写缓冲区，然后会到同步到服务端的读缓冲区里，服务端fd里的写缓冲区也一样。
  + *与匿名管道的区别？*
  + **默认是阻塞的**，对应的是fd的设备的文件性质，不是wirte(),read()函数的性质。
+ 匿名管道
  + 分为读、写两端  **队列**数据结构
  + 管道的读写两端分别对应一个文件描述符
  + 内核缓冲区（内存中一块存储空间）
  + **默认是阻塞的**

#### 12、知识点复习（）

+ 

#### 13、大端和小端存储（）

+ 

#### 14、大小端转换函数

### day11、TCP三次握手-并发

#### 1、学习目标

#### 2、知识点回顾（）

+ 

#### 3、tcp客户端代码实现（20200401）

+ [client_tcp.c]

#### 4、socket函数封装（20200402）

+ [wrap.c]查看
  + **Man文档跳转的时候，不区分大小写**，可以把accept()的函数重装包装成Accpet()。
  + *用啥+K可以跳转？lionel*
  + bind(),connect(),listen(),socket(),close()，这些返回-1时，就打印错误。
  + accept()、read()，write()返回-1，都递归调用。**read和write会阻塞**。
  + readn()是自己写的，多了个**应该读取的字节数`n`**；
  + writen()也是自己写的，跟readn()一样
  + Readline()调用一个静态函数my_read()

#### 5、TCP三次握手（20200403）

+ 连接服务器的过程中完成三次握手，6个标志位：
  + SYN：请求建立连接
  + ACK：应答
  + FIN：断开连接
  + RST
  + URG
  + PSH
+ **第1次握手是由客户端发起**，
  + 客户端：
    + SYN标志位+32位序号（随机产生）+数据（也可以不带数据）
  + 服务器
    + 判断SYN值为1时，第1次握手才算成功。
+ 第2次握手
  + 服务器
    + ACK标志位+32确认序号（在随机序号基础上+1）+数据（也可以不带数据）
    + 发起一个连接请求：SYN标志位+32位序号（随机产生）+数据（也可以不带数据）
  + 客户端
    + 检测ACK标志位是不是为1
    + 检测32位确认序号是否是自己随机序号基础上加1
+ 第3次握手
  + 客户端
    + 发送确认数据包：ACK标志位+32位确认序号
  + 服务器：
    + 检测：ACK是否为1，
    + 检测：确认序号是否正确
+ *思考*
  + 带数据的时候，回的确认序号是多少？（大小后再加1？）

#### 6、TCP的数据传输过程（20200403）

+ MSS（最大数据长度）：客户端告诉服务器，你给我发的数据长度的值。
+ 三次握手，建立连接的过程
  + 客户端：`connect()`
  + 服务器：`accept()`
+ 数据传输
  + 客户端：编号（对方最后发送ACK的时候携带的确认序号）+ACK+对方最后一次的ACK编号
  + 服务端：ACK+确认+数据
  + 客户端：ACK+确认
+ *这部分其实没太完全懂，但看图能说出个大概来*，**数据连接过程中没有SYN关键字**

#### 07、四次挥手（20200403）

+ **哪一些主动主动断开连接都可以**。
+ 需要一个标志位：FIN。
+ 第一次挥手
  + 客户端（发送断开的请求）：
    + FIN+对方最后发送ACK的时候携带的确认序号+数据（可以不带）；
    + ACK+序号（对方的发送的序号+长度）
  + 服务端：
    + 检测FIN值是否为1
    + ACK的作用：告诉对方之前发的数据收到了多少
+ 第二次挥手
  + 服务器（给Client确认数据包）
    + ACK+确认编号（FIN对应的序号+1+数据大小）
  + 客户端：
    + 检测：ACK的值
    + 检测：确认序号
+ 第三次挥手：（**服务器发起的告别过程**）
  + 服务器端（发送断开连接的请求）
    + FIN+序号（最后一次收到，对方的ACK）
    + ACK+序号
  + 客户端：
    + 数据检测，数据是不是收到
+ 第四次挥手
  + 客户端：
    + ACK+序号（收到的ACK序号+1）
+ **第2次和第3次都是同一个人发的**，*主要是序号的值，要确认一下*。
+ 在代码中表现就是
  + 客户端和服务端都是用`close()`

#### 08、滑动窗口（20200403）

+ **滑动窗口**就是缓存，对应的“16位窗口大小”，就是记录的缓存大小。
+ WIN 4096
  + win-滑动窗口
  + 4096-滑动窗口对应的缓冲区大小
  + **客户端和服务端的WIN，大小值可以不一样**，一般都不一样。  
+ 可以发很多条，服务器再答复。

#### 09、多进程并发服务器分析（20200404）

+ **并发**：在某个时间点处理的个数。
+ 服务端只处理单连接
  + 创建套接字
  + 绑定
  + 监听
  + 接受连接请求
  + 通信
+ 服务端处理多连接
  + 监听：最多可以128个【listen(fd,128)】
  + 接受连接请求
    + 让父进程创建子进程，去连接客户端A
    + **父进程只等待连接请求**，有请求就fork()一下
+ 使用多进程的方式，解决服务器处理多连接的问题
  + 共享
    + **读时共享，写时复制**，读的时候对应的同一个物理地址；写的时候，就会开辟新的空间，再读就会去新开辟的空间读。
    + 共享的内容有：文件描述符；内存映射区--mmap创建出来的；
  + 父进程的角色是什么？
    + 等待接收客户端连接 ---accept()
      + 有连接，创建一个子进程 fork()
      + **将通信的文件描述符关闭**
  + 子进程的角色是什么？
    + 通信
      + 使用accept()返回值，就是fd。
    + **关掉监听的文件描述符**
      + 主要原因是：浪费资源（因为fd的个数有限，才1024个）
  + 创建的进程的个数有限制吗？
    + 有，受硬件限制。
    + **文件描述符默认有上限是1024个**。
  + 子进程资源回收
    + 不回收的话，会被init回收或变成僵尸进程。
    + wait()或waitpid()回收。
    + 用信号回收
      + 信号捕捉（signal，sigaction）推荐后者
      + 捕捉SIGCHLD信号
+ 文件描述符（有2个）？
  + 用于监听的
  + 用于通信的

#### 10、多进程并发服务器伪代码（20200404）

+ [多进程并发服务器伪代码.c]

#### 11、多进程并发服务器代码实现（20200404）

+ [process_server.c]

#### 12、多线程并发服务器实现思路（20200404）

+ 服务器收到客户端的connect()，可以当作是主线程收到，然后`pthread_creat()`创建子线程处理。
  + 把文件描述传到子线程内部，进行read/write操作。
+ 线程共享：
  + 全局数据区
  + 堆区数据
  + 一块有效内存的地址
+ **每个线程都要备份独立的处理**，把处理封装到结构体里，同时在回调函数里处理。

#### 13、多线程版客户端代码实现（20200404）

+ [pthread_server.c]



### day12、TCP状态转换-select-poll

#### 01、知识点概述

#### 02、三次握手四次挥手复习

#### 03、多进程多线程并发复习（）

#### 04、recv和send函数（20200406）

+ 数据接收
  + read()
  + recv()
+ 数据发送
  + write()
  + send()
+ 两者是可替代的，**区别在于后面的函数多了一个参数flags，赋值为0即可**。
  + UDP的话，用的是`recvfrom()`和`sendto()`**它们的flags也赋值为0**。

#### 05、tcp状态转换（20200408）

+ 客户端：`CLOSED`->`SYN_SENT`->`ESTABLISTHED`->数据传偷中状态不变->**谁先发送挥手请求，谁先变**->`FIN_WAIT_1`->`FIN_WAIT_2`->`TIME_WAIT`->`CLOSED`
  + 主动断开的一方，最后的状态是**TIME_WAIT**。
+ 服务端：`CLOSED`->`LISTEN`->`SYN_RCVD`->`ESTABLISTHED`->`CLOSE_WAIT`->`LAST_ACK`->`CLOSED`
  + *这不是服务端主动断开连接*。

#### 06、2msl等待时长（20200408）

+ 能捕捉到的状态（netstat命令会捕捉）
  + LISTEN
  + ESTABLISHED
+ 主动断开连接的一方到`TIME_WAIT`状态时，会等待2MSL时长，一个MSL是30秒，2个就是1分钟。
  + 怕对方没有收到，用这个2MSL再发送一次。

#### 07、半关闭（20200408）

+ 如何理解？
  + **有一端关闭，另一端没关闭**
  +  A给B发送是FIN（A调用了close函数），但是B没有给A发送FIN（B没有调用close）
  + 即A断开了与B的连接，B没有断开与A的连接。
+ 特点：
  + A不能给B发送数据，但能收到B发送的数据。
  + B能给A发送数据
+ 函数：`shutdown(int sockfd, int how)`
  + how
    + SHUT_RD 0读
    + SHUT_WR 1 写
    + SHUT_RDWR 2 读写
  + **把拷贝的文件描述符也不能用了**
+ dup,dup2
  + 复制文件描述符，dup2()还能得定向。
+ 思考：close函数能否实现半关闭？

#### 08、netstat命令（20200407）

+ 用netstat捕捉进程的状态（套接字通信）
  + -a，默认不显示LISTEN相关，所以要用a
  + -p，显示建立相关链接的程序名
  + -n，拒绝显示别名，能显示数字的全部转化为数字
  + -t（tcp）仅显示tcp相关选项
  + -u（udp）仅显示udp相关选项
  + l 仅列出有在Listen（监听）的服务状态
+ `grep -apn`
  + **服务端永远有个监听套接字**，最后看名称判断服务器还是客户端。
  + 第1个ip+port表示当前名称的本地IP+Port，第2个是连的远端的IP+Port。
+ **`TIME_WAIT`，主动断开的一方，会有一个TIME_WAIT状态**，这个等待大概是1min。
  + `FIN_WAIT2`和`CLOSE_WAIT`又分别是谁是发起人呢？

#### 09、端口复用设置（20200409）

+ 作为server端主动断开连接后，再启动会有“Address already in use”，原因是
  + **主动断开连接的一方有2MSL的等待时长**。--lionel，我在定位问题的日志里就见过，但当时不知道啥原因呢。
+ 当然也可以用**端口复用**的方式解决。
+ 端口复用的用途
  + 防止服务器重启时之前绑定的端口还未释放
  + 程序突然退出而系统没有释放端口
+ 设置方法
  + `int opt = 1; setsockopt(sockfd, SOL_SOCKET,SO_REUSEADDR,(const void*)&amp;opt, sizeof(opt));`
    + **文件描述符是监听描述符**。
+ 注意事项
  + **在绑定之前设置端口复用的属性**。

#### 10、IO多路转换讲解（20200408）

+ IO操作方式
  + 阻塞等待
    + 好处：不占CPU宝贵的时间片
    + 缺点：同一时刻只能处理一个操作，效率低
    + **多进程/多线程**解决，只等待，再用子线程/子线程处理相应业务，**创建进程/线程太耗费资源**
  + 非阻塞，忙轮询
    + 优点：提高了程序的执行效率
    + 缺点：需要占用更多的CPU和系统资源
    + **单任务/多任务**（不断问）
  + **解决方案：使用IO多路转接技术select/poll/epoll**
    + 第一种：select/poll
      + **先委托内核帮我们检测一下有哪些客户端会跟我通信**，通过`select()`来实现。
      + **select()只识数不认字，只会告诉你有几个快递（客户端）到了**，但是哪个快递，需要挨个遍历所有客户端。
      + poll遍历的是线性表。
    + 第二种：epoll
      + **epoll()不仅告诉你数量，也会告诉你哪个快递公司的快递**。
      + epoll遍历的是红黑树。
+ *以取快递的例子来讲*

#### 11、内核大致是如何实现IO连接的（20200408）

+ 先构造一张有关文件描述符的列表，将要监听的文件描述符添加到该表中
  + 阻塞信号集表/自定义信号集表，再用`sigpromask()`是这两张的桥梁。
+ 然后调用一个函数，监听该表中的文件描述符，直接这些描述符表中的一个进行I/O操作时，该函数才返回
  + 该函数为阻塞函数
  + 函数对文件描述符的检测操作是由内核完成的
+ 在返回时，它告诉进程有多少（哪些）描述符要进行I/O操作
+ *通过调用selec()函数，把构造的文件描述符列表给到内核？*--是这样的吗？

#### 12、select的参数和返回值（20200409）

+ `int select(int nfds, fd_set *readfds, fd_set *writefds,
                    fd_set *exceptfds, struct timeval *timeout);`
  + ndfs：一组描述符中最大的值再加1；最多传1024
    + `fd_set`是个数组，大小是16个，所以最多传1024（16 乘 8位 乘 字节），所以最多1024个标志位。
  + readfds：**传入传出参数**，读集合
  + writefds：一般传空  （写是主动操作，不捕捉）
  + exceptfds：一般传空  **异常集合**
  + timeout：**通过设置它来确定是否阻塞**
    + NULL：永久阻塞（当检测到fd有变化的时候返回）
    + 要让结构体变量的a有值，a.tv_sec=0，a.tv_usec=0。
+ 文件描述符集类型：`fd_set rdset;`
  + FD_ZERO()清空
  + FD_CLR()删除某项
  + FD_SET()添加文件描述符
  + FD_ISSET()判断是否存在集合中 **没有设置上，就是0**
+ select函数的优缺点
  + 优点
    + 跨平台
  + 缺点
    + 内核的开销太大

#### 13、复习（）

#### 14、select工作过程（）

+ 

#### 15、select伪代码实现（）

+ 

#### 16、select代码实现（）

+ 

#### 17、poll函数介绍（）

+ 

#### 18、poll实现IO转接代码分析（）

+ 



### day13、TCP状态转换select-epoll

#### 01、知识点概述

#### 02、三次（20200314）

+ **创建“进程组”，“会话”的概念，主要是便于管理**。

+ 进程组：
  + 1个父进程创建5个子进程，父进程就是进程组的组长。
  + 多个进程在同一个组，第一个进程默认是组长。
+ 会话：
  + 含有多个进程组。
  + **组长不可以创建创建会话，必须是组员创建**。
  + 注意事项：
    + 调用进程不能是进程组组长，该进程变成新会话首进程（session header）
    + 该进程成为一个新进程组的组长进程
    + 新会话丢弃原有的控制终端，该会话没有控制终端
    + 该调用进程是组长进程，则出错返回
    + 建立新会话时，先调用fork，父进程终止，子进程调用setsid。
+ **创建会话的步骤：**
  + 创建子进程，父进程去死，子进程自当会长。
+ `getsid()`和`setsid()`中的s表示session。
+ 守护进程
  + **与终端无关**，终端关闭，进程依然存在。
  + **原理就是**SIGHUP，通过1号信号来关闭相关进程。
  + **以d结尾的进程**，是守护进程，比如`systemd`，如果是`?`代表与终端无关。
  + **创建守护进程，最关键的一步是调用setsid函数创建一个新的session，并成为session Leader**。
+ **创建守护进程模型**
  + 1、创建子进程，父进程退出
  + 2、在子进程中创建新会话
  + 3、改变当前目录为根目录 （非必须），根目录没权限，用`$HOME`
  + 4、重设文件权限掩码（非必须），`umask`命令，当前进程的掩码
  + 5、关闭文件描述符（非必须），为了避免浪费资源
  + 6、开始执行守护进程核心工作
  + 7、守护进程退出处理程序模型（**一般不退出**）
  + **调试的时候，先不要杀死父进程，先用父进程执行核心工作，逻辑没问题了，再执行创建子进程，杀死父进程**。

#### 03、守护进程创建（20200314）

+ 创建一个守护进程（作业）：每分钟在$HOME/log/创建一个文件，程序名.时间戳

#### 04、守护进程扩展了解（20200314）

+ `nohup`可以阻塞1号进程。 即`nohup ./a.out &`  //&表示后台运行，SIGHUP
+ **通过nohup指令也可以达到守护进程创建的效果**。会让cmd收不到SIGHUP信号。

#### 05、线程有关的概念（20200315）

+ **线程**：轻量级的进程，本质仍是进程（在Linux下）
+ 进程：独立地址空间，有PCB
  + 一个进程默认就是一个线程，但可以有多个线程。**相当于合租**
+ 线程：有PCB，**没有独立的地址空间**。【线程就执行一个函数，所以就在stack上不共享。】
+ **Linux下：线程（最小的执行单位）；进程（最小分配资源单位，可看作只有一个线程的进程）**。
+ **进程是苦力，是真正干活的**。（车间是个进程的话；车间的员工就是线程）。
+ 1个CPU只有1核的话，多线程有没有用？**没有用，因为只有1个线程获得CPU**.
+ **内核实现都是通过clone函数实现的，所以从内核看没有区别**。线程所有操作函数pthread*是库函数，而非系统调用。
+ 多线程和多进程其实区别不大，**多线程通讯时节省了很多成本**，类unix系统早期没有线程的概念，引入自windows。【windows里玩得比较6】
+ 查看lwp号：`ps -Lf pid`

#### 06、线程的优点和缺点（20200315）

+ 线程共享资源
  + 文件描述符表
  + 每种信号的处理方式
  + 当前工作目录
  + 用户ID和组ID
  + 内存地址空间（.text/.data/.bss/heap/共享库）
+ **尽量不要信号和多线程一起使**，因为其中任何一个都已经很乱了。
+ 线程非共享资源
  + 线程Id
  + 处理器现场和栈指针（内核栈）
  + 独立的栈空间（用户空间栈）
  + errno变量
    + 用`perror()`不行了，**线程里要用`strerror()`才行**。
  + 信号屏蔽字
  + 调度优先级
+ 线程优、缺点
  + 优点： 提高程序并发性；占用资源小，开销小；数据通信、共享数据方便
  + 缺点：库函数，不稳定；调试、编写困难；对信号支持不友好
  + 优点相对突出，缺点均不是硬伤。**Linux下由于实现方法，导致进程、线程差别不是很大**。
+ 引入多线程的目的：**为了更好的使用CPU**。

#### 07、创建一个线程（20200315）

+  **pthread_开头的函数**，以`pthread_create()`为例，**编译和链接时要加上-lpthread**。
  + thread：线程id，传出参数
  + attr：线程的属性 **大多数时候不用**
  + 第三个参数 函数指针 void* func(void*)
  + arg：线程执行函数的参数
  + 返回值：成功返回0；失败返回errno。
+ **线程是个库函数，要加pthread**.
+ **`pthread_self()`用于获取当前线程id。**
+ `set -o vi` **快捷查找之前的命令**。 [关于set -o vi的使用](https://blog.csdn.net/cnsdlywei/article/details/81906730) --设置shell里vi的快捷键。
  + 设置后的vi的快捷键在shell中使用 
+ 在$HOME的.bashrc增加
  + `alias echomake='cat ~/bin/makefile.template>>makefile'`

#### 08、线程的退出（20200316）

+ [pthread_exit.c]
  + **这个地方只是退了，但没有看到返回值**，具体要一节代码展现。
+ 线程退出函数，线程退出注意事项
  + 在线程中使用pthread_exit
  + 在线程中使用return（**主控线程return代表退出进程**）
  + **exit代表退出整个进程**。
+ **关注一下pthread_exit()的参数**。

#### 09、线程的回收（20200316）

+ [pthread_rtn.c]
+ 不回收，就会变成**僵尸线程**。
+ `pthread_join()`
  + thread：创建的时候传出的第一个参数
  + retval：代表的传出线程的退出信息（代码中的return值）
+ **线程回收，也是阻塞等待回收**

#### 10、上午内容的回顾

#### 11、杀死线程（20200316）

+ [pthread_cancel.c]
+ `pthread_cancel()`参数是pthread_t
  + **线程是被取消的话，退出值就是-1**，因为`#define PTHREAD_CANCELD((void*)-1)`
  + 失败返回errno，成功返回0。
+ **如何没有cancel point的话，就没法杀死线程**。用`pthread_testcancel()`来强行设置取消点。

#### 12、线程分离（20200317）

+ **好处**：线程回收就不用自己管了，不需要用`pthread_join()`回收资源了。
+ `pthread_deatch(pthread_t thread)`

#### 13、线程属性设置分离（20200319）

+ [pthread_var.c]
  + **全局变量**
+ `pthread_equal()`判断两个线程是否相等
  + **在某个进程内是唯一的，但整个系统中并不是唯一的**。
+ [npthread.c]**创建多个线程**
+ **线程的分离状态（掌握）**
  + `pthread_attr_setdetachstate()`
    + attr init初始化的属性
    + detachstate的值
      + PTHREAD_CREATE_DETACHED **线程分离**
      + PTHREAD_CREATE_JOINABLE  **允许回收**
  + 初始化`pthread_attr_init()`
  + 销毁`pthread_attr_destory()`

#### 14、线程注意事项（20200320）

+ NPTL
  + `getconf GNU_LIBPTHREAD_VERSION`查看pthread版本
  + NPTL实现机制（posix）**Native POSIX Thread Library**
  + gcc指定 -lpthread
+ 线程使用注意事项
  + 主线程退出其它线程不退出，主线程应调用`pthread_exit`，return退出会进程退出。
  + 避免僵尸线程
    + pthread_detach
    + pthread_join
    + pthread_create指定分离属性
  + malloc和mmap申请的内存可以被其它线程释放（必然的，因为它们是共享的）
+ 创建多少个线程合适
  + **CPU核数 double一下后，再加2**

#### 15、总结和作业

#### 16、线程同步的概念（20200321）

+ （银行卡，存折）对应同一个账户；不同的人对分别（银行卡，存折）的操作，**得有先后顺序**，不然余额就乱了。
+ 同步概念
  + 数据库同步：两个或多个数据库内容保持一致
  + 文件同步：两个或多个文件夹里的文件保持一致
  + 编程中，**“同”**指协同、协助，互相配合。
+ 线程同步：
  + **同步即协同步调，按预定的先后次序运行**。
  + 一个线程发出某一功能调用时，在没有得到结果前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。
+ **解决同步的问题：加锁！**
+ 数据混乱原因：
  + 资源共享
  + 调度随机（意味着数据访问会出现竞争）
  + 线程间缺乏必要的同步机制**只能解决第3点**。

#### 17、mutex相关的函数（20200321）

+ [thr_write.c] *这个自己就没写*
+ `pthread_mutex_`开头的函数
+ `pthread_mutex_init`
  + `pthread_mutex_t *restrict`，**restrict约束该块内存区域对应的数据，只能通过后面的变量进行访问和修改**。
  + `pthread_mutexattr_`开头，**这个用不着**，传`NULL`即可。
+ **mutex是互斥量** -- 锁。
+ `pthread_mutex_lock()` 给共享资源加锁
  + mutex init初始化的锁
  + 如果未所，成功，给线程加锁；
  + 如果已锁，**阻塞等待**。
+ `pthread_mutex_destroy()` 摧毁锁
  + mutex 传入的锁
+ pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; **常量初始化**，可以不用`init`。

### day14、广播-组播-本地套接字

#### 01、内容回顾

#### 02、学习目标

#### 03、互斥量的使用（20200329）

+ `pthread_mutex_开头的函数`
+ 互斥量的使用频繁：
  + 初始化
  + 加锁
  + 执行逻辑---操作共享数据
  + 释放锁
+ 注意事项：**加锁需要最小粒度，不要一直占用临界区**。
+ `pthread_mutex_trylock()`
+ [mutex_trylock.c]
  + **错误码的头文件`/usr/include/asm-generic/errno-bash.h`**

#### 04、死锁（20200329）

+ 锁了又锁（锁了2次）
  + 自己加了一次锁成功，又加了一次。
+ **交叉锁**（自己抢占了一个，又抢占对方的）
  + 解决办法：**每个线程申请锁的顺序要固定（或一致）*
  + 如果申请到一把锁，申请另外一把锁的时候申请失败，应该释放已经掌握的。
+ **互斥锁只是建议锁**，防君子不防小人。

#### 05、读写锁（20200329）

+ 与互斥量类似，但读写锁允许更高的并发性。其特性为：**写独占，读共享**。
+ **读的写的时候不改变数据，不用加锁，只有写的时候，才加锁**。
+ 读写锁特性：
  + **写的优先级高**
  + 多个读的时候才共享，但凡有写的时候需要锁
+ `pthread_rwlock_init()`
+ **读写锁只有一把**，有不同的状态
  + 未加锁
  + 读锁（读模式下加锁）
  + 写锁（写模式下加锁）
+ 读写锁场景练习：
  + 线程A写锁成功，线程B请求读锁
    + 线程B阻塞
+ *学到第5分钟*

#### 06、条件变量介绍和生产者和消费者模型（20200331）

+ 因为竞争后，抢到了后发现里面资源自己用不了，所以引入**条件变量**。
+ 条件变量，本身不是锁，但可以引起阻塞。**竞争者可以阻塞在条件变量上**。
+ `pthread_cond_init()` **条件变量**相关的函数，初始化
+ `pthread_cond_timedwait()` **超时等待**中的
  + abstime：**直接在struct timespec**上加时间即可。`time(NULL)+600`==>设置超时600s。
+ `pthread_cond_wait()` 条件变量阻塞等待
+ **条件变量不是锁，要和互斥量组合使用**。
  + 先拥有锁，释放锁，阻塞在条件变量上。
+ `pthread_cond_destory()`销毁一个条件变量
+  **唤醒至少一个阻塞在条件变量cond上的线程**。`pthread_cond_singal()`
+ 唤醒在条件变量上的所有线程：`pthread_cond_broadcast()`

#### 07、上午内容回顾

#### 08、条件变量生产者消费者模型实现（20200331）

+ **条件变量的作用**：避免没有必要的竞争。
+ [cond_produce.c]

#### 09、条件变量生产者消费者模型演示

#### 10、信号量的概念（20200331）

+ **信号量--加强版的互斥锁**。允许多个线程访问共享资源。
  + mutex_lock，就是mutex--
  + mutex_unlock，就是mutex++
+ `sem_init()`
  + sem定义的信号量，传出
  + pshared：
    + 0代表线程信号量
    + 非0代表进程信号量
  + value：允许的并发数
+ 摧毁信号量`sem_destory()`
+ 申请信号量，申请成功，value--，当信号量为0时，阻塞`sem_wait()`
+ `sem_post()`释放信号量，value++
+ `sem_wait`相当于--，`sem_post`相当于++
+ **编译的时候，必须要加上pthread**。

#### 11、信号量实现生产者和消费者分析

#### 12、信号量实现生产者和消费者

#### 13、文件锁单开进程

#### 14、哲学家就餐模型

#### 15、总结

### day15、libevent

### day16、xml json

