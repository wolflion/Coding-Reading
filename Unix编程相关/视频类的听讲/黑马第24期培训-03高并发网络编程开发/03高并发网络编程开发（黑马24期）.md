## 内容

### day10、网络编程基础socket

#### 01、知识点概述（20200401）

+ 第8-10天，自己实现一个Mini Web服务器（有两个功能）
  + 处理网络I/O
  + 业务处理

#### 02、网络开发两种设计模式（）

+ 

#### 03、网络模型分层（）

+ 

#### 04、以太网帧协议（）

+ 

#### 05、IP协议（）

+ 

#### 06、UDP协议（）

+ 

#### 07、TCP协议（）

+ 

#### 08、TCP-IP四层模型协议封装（）

+ 

#### 09、UDP和TCP讲解（）

+ 

#### 10、什么是套接字（20200401）

+ **Socket是网络通信的函数接口的总称**，封装了传输层的协议（TCP，UDP）。
+ 浏览器，应用层用的是HTTP，往下封装的是TCP。
+ Socket：IP+Port。

#### 11、套接字内存模型（20200401）

+ socket通信
  + 服务器端（插座）**被动**让客户端连接；
  + 客户端（电风扇、电视）**主动**
+ socket编程--**网络IO编程**
  + 读写操作（read/wirte)
    + 文件描述符
  + 创建一个套接字，得到的是文件描述符，**这个fd也是一块内核缓冲区**
  + **内核缓冲区分为两部分（读缓冲区，写缓冲区）**，这是系统处理好的，不用应用程序关心。
  + 客户端的数据先write到写缓冲区，然后会到同步到服务端的读缓冲区里，服务端fd里的写缓冲区也一样。
  + *与匿名管道的区别？*
  + **默认是阻塞的**，对应的是fd的设备的文件性质，不是wirte(),read()函数的性质。
+ 匿名管道
  + 分为读、写两端  **队列**数据结构
  + 管道的读写两端分别对应一个文件描述符
  + 内核缓冲区（内存中一块存储空间）
  + **默认是阻塞的**

#### 12、知识点复习（）

+ 

#### 13、大端和小端存储（）

+ 

#### 14、大小端转换函数

### day11、TCP三次握手-并发

#### 1、学习目标

#### 2、知识点回顾（）

+ 

#### 3、tcp客户端代码实现（20200401）

+ [client_tcp.c]

#### 4、socket函数封装（20200402）

+ [wrap.c]查看
  + **Man文档跳转的时候，不区分大小写**，可以把accept()的函数重装包装成Accpet()。
  + *用啥+K可以跳转？lionel*
  + bind(),connect(),listen(),socket(),close()，这些返回-1时，就打印错误。
  + accept()、read()，write()返回-1，都递归调用。**read和write会阻塞**。
  + readn()是自己写的，多了个**应该读取的字节数`n`**；
  + writen()也是自己写的，跟readn()一样
  + Readline()调用一个静态函数my_read()

#### 5、TCP三次握手（20200403）

+ 连接服务器的过程中完成三次握手，6个标志位：
  + SYN：请求建立连接
  + ACK：应答
  + FIN：断开连接
  + RST
  + URG
  + PSH
+ **第1次握手是由客户端发起**，
  + 客户端：
    + SYN标志位+32位序号（随机产生）+数据（也可以不带数据）
  + 服务器
    + 判断SYN值为1时，第1次握手才算成功。
+ 第2次握手
  + 服务器
    + ACK标志位+32确认序号（在随机序号基础上+1）+数据（也可以不带数据）
    + 发起一个连接请求：SYN标志位+32位序号（随机产生）+数据（也可以不带数据）
  + 客户端
    + 检测ACK标志位是不是为1
    + 检测32位确认序号是否是自己随机序号基础上加1
+ 第3次握手
  + 客户端
    + 发送确认数据包：ACK标志位+32位确认序号
  + 服务器：
    + 检测：ACK是否为1，
    + 检测：确认序号是否正确
+ *思考*
  + 带数据的时候，回的确认序号是多少？（大小后再加1？）

#### 6、TCP的数据传输过程（20200403）

+ MSS（最大数据长度）：客户端告诉服务器，你给我发的数据长度的值。
+ 三次握手，建立连接的过程
  + 客户端：`connect()`
  + 服务器：`accept()`
+ 数据传输
  + 客户端：编号（对方最后发送ACK的时候携带的确认序号）+ACK+对方最后一次的ACK编号
  + 服务端：ACK+确认+数据
  + 客户端：ACK+确认
+ *这部分其实没太完全懂，但看图能说出个大概来*，**数据连接过程中没有SYN关键字**

#### 07、四次挥手（20200403）

+ **哪一些主动主动断开连接都可以**。
+ 需要一个标志位：FIN。
+ 第一次挥手
  + 客户端（发送断开的请求）：
    + FIN+对方最后发送ACK的时候携带的确认序号+数据（可以不带）；
    + ACK+序号（对方的发送的序号+长度）
  + 服务端：
    + 检测FIN值是否为1
    + ACK的作用：告诉对方之前发的数据收到了多少
+ 第二次挥手
  + 服务器（给Client确认数据包）
    + ACK+确认编号（FIN对应的序号+1+数据大小）
  + 客户端：
    + 检测：ACK的值
    + 检测：确认序号
+ 第三次挥手：（**服务器发起的告别过程**）
  + 服务器端（发送断开连接的请求）
    + FIN+序号（最后一次收到，对方的ACK）
    + ACK+序号
  + 客户端：
    + 数据检测，数据是不是收到
+ 第四次挥手
  + 客户端：
    + ACK+序号（收到的ACK序号+1）
+ **第2次和第3次都是同一个人发的**，*主要是序号的值，要确认一下*。
+ 在代码中表现就是
  + 客户端和服务端都是用`close()`

#### 08、滑动窗口（20200403）

+ **滑动窗口**就是缓存，对应的“16位窗口大小”，就是记录的缓存大小。
+ WIN 4096
  + win-滑动窗口
  + 4096-滑动窗口对应的缓冲区大小
  + **客户端和服务端的WIN，大小值可以不一样**，一般都不一样。  
+ 可以发很多条，服务器再答复。

#### 09、多进程并发服务器分析（20200404）

+ **并发**：在某个时间点处理的个数。
+ 服务端只处理单连接
  + 创建套接字
  + 绑定
  + 监听
  + 接受连接请求
  + 通信
+ 服务端处理多连接
  + 监听：最多可以128个【listen(fd,128)】
  + 接受连接请求
    + 让父进程创建子进程，去连接客户端A
    + **父进程只等待连接请求**，有请求就fork()一下
+ 使用多进程的方式，解决服务器处理多连接的问题
  + 共享
    + **读时共享，写时复制**，读的时候对应的同一个物理地址；写的时候，就会开辟新的空间，再读就会去新开辟的空间读。
    + 共享的内容有：文件描述符；内存映射区--mmap创建出来的；
  + 父进程的角色是什么？
    + 等待接收客户端连接 ---accept()
      + 有连接，创建一个子进程 fork()
      + **将通信的文件描述符关闭**
  + 子进程的角色是什么？
    + 通信
      + 使用accept()返回值，就是fd。
    + **关掉监听的文件描述符**
      + 主要原因是：浪费资源（因为fd的个数有限，才1024个）
  + 创建的进程的个数有限制吗？
    + 有，受硬件限制。
    + **文件描述符默认有上限是1024个**。
  + 子进程资源回收
    + 不回收的话，会被init回收或变成僵尸进程。
    + wait()或waitpid()回收。
    + 用信号回收
      + 信号捕捉（signal，sigaction）推荐后者
      + 捕捉SIGCHLD信号
+ 文件描述符（有2个）？
  + 用于监听的
  + 用于通信的

#### 10、多进程并发服务器伪代码（20200404）

+ [多进程并发服务器伪代码.c]

#### 11、多进程并发服务器代码实现（20200404）

+ [process_server.c]

#### 12、多线程并发服务器实现思路（20200404）

+ 服务器收到客户端的connect()，可以当作是主线程收到，然后`pthread_creat()`创建子线程处理。
  + 把文件描述传到子线程内部，进行read/write操作。
+ 线程共享：
  + 全局数据区
  + 堆区数据
  + 一块有效内存的地址
+ **每个线程都要备份独立的处理**，把处理封装到结构体里，同时在回调函数里处理。

#### 13、多线程版客户端代码实现（20200404）

+ [pthread_server.c]



### day12、TCP状态转换-select-poll

#### 01、内容复习

#### 02、作业说明

#### 03、信号的回顾（20200308）

+ **杀死进程，就是通过信号来产生，信号是内核产生和处理的**。
+ 信号四要素：
  + 编号
  + 名称
  + 事件
  + 默认处理动作（Term，Ign， Core，Stop，Cont）。 `man 7 signal` 终止，忽略，终止产生Core，暂停，继续
+ 信号的特点：
  + 简单
  + 不能携带大量信息
  + 特定条件下产生
+ **信号也叫软件产生的中断，有可能会有延迟**。
+ 信号的处理方式：
  + 执行默认动作（上面的5个）
  + 忽略
  + 捕捉
+ **9，19号信号不能捕捉，不能忽略，甚至不能阻塞**。

#### 04、学习目标（20200308）

+ 信号的基本概念
+ 信号相关的函数，信号集操作相关函数
+ **熟练掌握**信号捕捉函数signal()和sigaction()
+ **熟练掌握**使用信号完成子进程的回收。
  + *加上wait()，子进程退出的时候回收回来，不用傻等了*。--这个不是太熟悉，要学习一下。lionel。

#### 05、阻塞信号集，未决信号集信号产生（20200308）

+ **递达**：递送并且到达进程。
+ **未决**：产生和递达之间的状态。主要由于阻塞（屏蔽）导致该状态。
+ 集合理解为位图，**最大的就是31，从1号开始**，0号信号有特殊含义。
+ **未决信号集**：来了之后先把信号置为1，信号处理之后置为0。
+ **阻塞信号集**，用于影响**未决信号集**，一直阻塞的话，一直未决。
+ 信号的产生
  + 终端按键：`ctrl+C`
  + 硬件异常：非法内存访问
  + kill函数/命令产生信号：
  + 系统API产生信号：`int kill(pid_t pid, int sig);`
    + pid大于0，要发送的进程ID
    + pid等于0，代表当前调用进程组内所有进程
    + pid等于-1，代表有权限发送的所有进程
    + pid小于0，代表-pid对应的组内所有进程
    + sig对应的信号
+ **练习**：某个子进程把父进程杀死
  + [killfather.c]

#### 06、raise和abort（20200309）

+ [kill3.c]
+ `int raise(int sig)`自己给自己发送信号。
+ `abort()`自己给自己发一个SIGABRT的信号。
+ [raise_abort.c]

#### 07、alarm发送信号（20200309）

+ alarm
  + 定时给自己发送SIGALRM
  + 几秒后发送信号
  + 返回值：上次闹钟剩余的描述
  + 特别的，如果传入参数秒为0，代表取消闹钟

#### 08、setitimer使用（20200310）

+ 周期性的发送信号。
+ 原型
  + new_value 要设置的闹钟时间
  + old_value 原闹钟时间
+ **which的3种值，对应不同的处理信号**。
  + ITIMER_REAL，自然定时法，SIGALRM
  + ITIMER_VIRTUAL 计算进程执行时间 SIGVTALRM
  + ITIMER_PROF  进程执行时间+调度时间
+ [setitimer.c]
+ [setitimer2.c]

#### 09、setitimer实现alarm前（20200310）

+ [myalarm.c]

#### 10、setitimer实现alram后（20200310）

+ 接上面[myalarm.c]

#### 11、1秒数数（20200310）

+ [count.c]
+ 用`time ./a.out`来计算。
+ 用`time ./a.out >1.log`来看区别。`tail -f 1.log`
+ printf比1.log慢的原因；**printf是行缓冲的，重定向是字节缓冲**。

#### 12、上午内容回顾

#### 13、信号集的函数（20200311）

+ **信号集**：
+ `sigemptyset()`：清空set，变为0。
+ `sigfillset()`：填充set，变为1。
+ `sigaddset()`：添加某个信号到信号集
+ `sigdelset()`：从信号集中删除某个信号（变为0）
  + 以上return0表示成功。
+ `sigismemeber()`：是否为集合里的成员
  + 返回1代表signum在集合中。
+ 设置阻塞或解决阻塞信号集：`sigpromask()`
  + how
    + SIG_BLOCK：设置阻塞
    + SIG_UNBLOCK：解除阻塞
    + SIG_SETMASK：设置set为新的阻塞信号集
  + set传入的信号集
    + 上面的几个函数
  + oldset：旧的信号集，传出（便于恢复之前的状态）
+ 读取当前的未决信号集：`sigpending()`

#### 14、打印未决信号集（20200311）

+ 打印当前信号集的打印[sigpending.c]

#### 15、select伪代码实现（）

+ 

#### 16、select代码实现（）

+ 

#### 17、poll函数介绍（）

+ 

#### 18、poll实现IO转接代码分析（）

+ 



### day13、epoll-UDP

#### 01、内容回顾

#### 02、守护进程相关的概念（20200314）

+ **创建“进程组”，“会话”的概念，主要是便于管理**。

+ 进程组：
  + 1个父进程创建5个子进程，父进程就是进程组的组长。
  + 多个进程在同一个组，第一个进程默认是组长。
+ 会话：
  + 含有多个进程组。
  + **组长不可以创建创建会话，必须是组员创建**。
  + 注意事项：
    + 调用进程不能是进程组组长，该进程变成新会话首进程（session header）
    + 该进程成为一个新进程组的组长进程
    + 新会话丢弃原有的控制终端，该会话没有控制终端
    + 该调用进程是组长进程，则出错返回
    + 建立新会话时，先调用fork，父进程终止，子进程调用setsid。
+ **创建会话的步骤：**
  + 创建子进程，父进程去死，子进程自当会长。
+ `getsid()`和`setsid()`中的s表示session。
+ 守护进程
  + **与终端无关**，终端关闭，进程依然存在。
  + **原理就是**SIGHUP，通过1号信号来关闭相关进程。
  + **以d结尾的进程**，是守护进程，比如`systemd`，如果是`?`代表与终端无关。
  + **创建守护进程，最关键的一步是调用setsid函数创建一个新的session，并成为session Leader**。
+ **创建守护进程模型**
  + 1、创建子进程，父进程退出
  + 2、在子进程中创建新会话
  + 3、改变当前目录为根目录 （非必须），根目录没权限，用`$HOME`
  + 4、重设文件权限掩码（非必须），`umask`命令，当前进程的掩码
  + 5、关闭文件描述符（非必须），为了避免浪费资源
  + 6、开始执行守护进程核心工作
  + 7、守护进程退出处理程序模型（**一般不退出**）
  + **调试的时候，先不要杀死父进程，先用父进程执行核心工作，逻辑没问题了，再执行创建子进程，杀死父进程**。

#### 03、守护进程创建（20200314）

+ 创建一个守护进程（作业）：每分钟在$HOME/log/创建一个文件，程序名.时间戳

#### 04、守护进程扩展了解（20200314）

+ `nohup`可以阻塞1号进程。 即`nohup ./a.out &`  //&表示后台运行，SIGHUP
+ **通过nohup指令也可以达到守护进程创建的效果**。会让cmd收不到SIGHUP信号。

#### 05、线程有关的概念（20200315）

+ **线程**：轻量级的进程，本质仍是进程（在Linux下）
+ 进程：独立地址空间，有PCB
  + 一个进程默认就是一个线程，但可以有多个线程。**相当于合租**
+ 线程：有PCB，**没有独立的地址空间**。【线程就执行一个函数，所以就在stack上不共享。】
+ **Linux下：线程（最小的执行单位）；进程（最小分配资源单位，可看作只有一个线程的进程）**。
+ **进程是苦力，是真正干活的**。（车间是个进程的话；车间的员工就是线程）。
+ 1个CPU只有1核的话，多线程有没有用？**没有用，因为只有1个线程获得CPU**.
+ **内核实现都是通过clone函数实现的，所以从内核看没有区别**。线程所有操作函数pthread*是库函数，而非系统调用。
+ 多线程和多进程其实区别不大，**多线程通讯时节省了很多成本**，类unix系统早期没有线程的概念，引入自windows。【windows里玩得比较6】
+ 查看lwp号：`ps -Lf pid`

#### 06、线程的优点和缺点（20200315）

+ 线程共享资源
  + 文件描述符表
  + 每种信号的处理方式
  + 当前工作目录
  + 用户ID和组ID
  + 内存地址空间（.text/.data/.bss/heap/共享库）
+ **尽量不要信号和多线程一起使**，因为其中任何一个都已经很乱了。
+ 线程非共享资源
  + 线程Id
  + 处理器现场和栈指针（内核栈）
  + 独立的栈空间（用户空间栈）
  + errno变量
    + 用`perror()`不行了，**线程里要用`strerror()`才行**。
  + 信号屏蔽字
  + 调度优先级
+ 线程优、缺点
  + 优点： 提高程序并发性；占用资源小，开销小；数据通信、共享数据方便
  + 缺点：库函数，不稳定；调试、编写困难；对信号支持不友好
  + 优点相对突出，缺点均不是硬伤。**Linux下由于实现方法，导致进程、线程差别不是很大**。
+ 引入多线程的目的：**为了更好的使用CPU**。

#### 07、创建一个线程（20200315）

+  **pthread_开头的函数**，以`pthread_create()`为例，**编译和链接时要加上-lpthread**。
  + thread：线程id，传出参数
  + attr：线程的属性 **大多数时候不用**
  + 第三个参数 函数指针 void* func(void*)
  + arg：线程执行函数的参数
  + 返回值：成功返回0；失败返回errno。
+ **线程是个库函数，要加pthread**.
+ **`pthread_self()`用于获取当前线程id。**
+ `set -o vi` **快捷查找之前的命令**。 [关于set -o vi的使用](https://blog.csdn.net/cnsdlywei/article/details/81906730) --设置shell里vi的快捷键。
  + 设置后的vi的快捷键在shell中使用 
+ 在$HOME的.bashrc增加
  + `alias echomake='cat ~/bin/makefile.template>>makefile'`

#### 08、线程的退出（20200316）

+ [pthread_exit.c]
  + **这个地方只是退了，但没有看到返回值**，具体要一节代码展现。
+ 线程退出函数，线程退出注意事项
  + 在线程中使用pthread_exit
  + 在线程中使用return（**主控线程return代表退出进程**）
  + **exit代表退出整个进程**。
+ **关注一下pthread_exit()的参数**。

#### 09、线程的回收（20200316）

+ [pthread_rtn.c]
+ 不回收，就会变成**僵尸线程**。
+ `pthread_join()`
  + thread：创建的时候传出的第一个参数
  + retval：代表的传出线程的退出信息（代码中的return值）
+ **线程回收，也是阻塞等待回收**

#### 10、上午内容的回顾

#### 11、杀死线程（20200316）

+ [pthread_cancel.c]
+ `pthread_cancel()`参数是pthread_t
  + **线程是被取消的话，退出值就是-1**，因为`#define PTHREAD_CANCELD((void*)-1)`
  + 失败返回errno，成功返回0。
+ **如何没有cancel point的话，就没法杀死线程**。用`pthread_testcancel()`来强行设置取消点。

#### 12、线程分离（20200317）

+ **好处**：线程回收就不用自己管了，不需要用`pthread_join()`回收资源了。
+ `pthread_deatch(pthread_t thread)`

#### 13、线程属性设置分离（20200319）

+ [pthread_var.c]
  + **全局变量**
+ `pthread_equal()`判断两个线程是否相等
  + **在某个进程内是唯一的，但整个系统中并不是唯一的**。
+ [npthread.c]**创建多个线程**
+ **线程的分离状态（掌握）**
  + `pthread_attr_setdetachstate()`
    + attr init初始化的属性
    + detachstate的值
      + PTHREAD_CREATE_DETACHED **线程分离**
      + PTHREAD_CREATE_JOINABLE  **允许回收**
  + 初始化`pthread_attr_init()`
  + 销毁`pthread_attr_destory()`

#### 14、线程注意事项（20200320）

+ NPTL
  + `getconf GNU_LIBPTHREAD_VERSION`查看pthread版本
  + NPTL实现机制（posix）**Native POSIX Thread Library**
  + gcc指定 -lpthread
+ 线程使用注意事项
  + 主线程退出其它线程不退出，主线程应调用`pthread_exit`，return退出会进程退出。
  + 避免僵尸线程
    + pthread_detach
    + pthread_join
    + pthread_create指定分离属性
  + malloc和mmap申请的内存可以被其它线程释放（必然的，因为它们是共享的）
+ 创建多少个线程合适
  + **CPU核数 double一下后，再加2**

#### 15、总结和作业

#### 16、线程同步的概念（20200321）

+ （银行卡，存折）对应同一个账户；不同的人对分别（银行卡，存折）的操作，**得有先后顺序**，不然余额就乱了。
+ 同步概念
  + 数据库同步：两个或多个数据库内容保持一致
  + 文件同步：两个或多个文件夹里的文件保持一致
  + 编程中，**“同”**指协同、协助，互相配合。
+ 线程同步：
  + **同步即协同步调，按预定的先后次序运行**。
  + 一个线程发出某一功能调用时，在没有得到结果前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。
+ **解决同步的问题：加锁！**
+ 数据混乱原因：
  + 资源共享
  + 调度随机（意味着数据访问会出现竞争）
  + 线程间缺乏必要的同步机制**只能解决第3点**。

#### 17、mutex相关的函数（20200321）

+ [thr_write.c] *这个自己就没写*
+ `pthread_mutex_`开头的函数
+ `pthread_mutex_init`
  + `pthread_mutex_t *restrict`，**restrict约束该块内存区域对应的数据，只能通过后面的变量进行访问和修改**。
  + `pthread_mutexattr_`开头，**这个用不着**，传`NULL`即可。
+ **mutex是互斥量** -- 锁。
+ `pthread_mutex_lock()` 给共享资源加锁
  + mutex init初始化的锁
  + 如果未所，成功，给线程加锁；
  + 如果已锁，**阻塞等待**。
+ `pthread_mutex_destroy()` 摧毁锁
  + mutex 传入的锁
+ pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; **常量初始化**，可以不用`init`。

### day14、广播-组播-本地套接字

#### 01、内容回顾

#### 02、学习目标

#### 03、互斥量的使用（20200329）

+ `pthread_mutex_开头的函数`
+ 互斥量的使用频繁：
  + 初始化
  + 加锁
  + 执行逻辑---操作共享数据
  + 释放锁
+ 注意事项：**加锁需要最小粒度，不要一直占用临界区**。
+ `pthread_mutex_trylock()`
+ [mutex_trylock.c]
  + **错误码的头文件`/usr/include/asm-generic/errno-bash.h`**

#### 04、死锁（20200329）

+ 锁了又锁（锁了2次）
  + 自己加了一次锁成功，又加了一次。
+ **交叉锁**（自己抢占了一个，又抢占对方的）
  + 解决办法：**每个线程申请锁的顺序要固定（或一致）*
  + 如果申请到一把锁，申请另外一把锁的时候申请失败，应该释放已经掌握的。
+ **互斥锁只是建议锁**，防君子不防小人。

#### 05、读写锁（20200329）

+ 与互斥量类似，但读写锁允许更高的并发性。其特性为：**写独占，读共享**。
+ **读的写的时候不改变数据，不用加锁，只有写的时候，才加锁**。
+ 读写锁特性：
  + **写的优先级高**
  + 多个读的时候才共享，但凡有写的时候需要锁
+ `pthread_rwlock_init()`
+ **读写锁只有一把**，有不同的状态
  + 未加锁
  + 读锁（读模式下加锁）
  + 写锁（写模式下加锁）
+ 读写锁场景练习：
  + 线程A写锁成功，线程B请求读锁
    + 线程B阻塞
+ *学到第5分钟*

#### 06、条件变量介绍和生产者和消费者模型（20200331）

+ 因为竞争后，抢到了后发现里面资源自己用不了，所以引入**条件变量**。
+ 条件变量，本身不是锁，但可以引起阻塞。**竞争者可以阻塞在条件变量上**。
+ `pthread_cond_init()` **条件变量**相关的函数，初始化
+ `pthread_cond_timedwait()` **超时等待**中的
  + abstime：**直接在struct timespec**上加时间即可。`time(NULL)+600`==>设置超时600s。
+ `pthread_cond_wait()` 条件变量阻塞等待
+ **条件变量不是锁，要和互斥量组合使用**。
  + 先拥有锁，释放锁，阻塞在条件变量上。
+ `pthread_cond_destory()`销毁一个条件变量
+  **唤醒至少一个阻塞在条件变量cond上的线程**。`pthread_cond_singal()`
+ 唤醒在条件变量上的所有线程：`pthread_cond_broadcast()`

#### 07、上午内容回顾

#### 08、条件变量生产者消费者模型实现（20200331）

+ **条件变量的作用**：避免没有必要的竞争。
+ [cond_produce.c]

#### 09、条件变量生产者消费者模型演示

#### 10、信号量的概念（20200331）

+ **信号量--加强版的互斥锁**。允许多个线程访问共享资源。
  + mutex_lock，就是mutex--
  + mutex_unlock，就是mutex++
+ `sem_init()`
  + sem定义的信号量，传出
  + pshared：
    + 0代表线程信号量
    + 非0代表进程信号量
  + value：允许的并发数
+ 摧毁信号量`sem_destory()`
+ 申请信号量，申请成功，value--，当信号量为0时，阻塞`sem_wait()`
+ `sem_post()`释放信号量，value++
+ `sem_wait`相当于--，`sem_post`相当于++
+ **编译的时候，必须要加上pthread**。

#### 11、信号量实现生产者和消费者分析

#### 12、信号量实现生产者和消费者

#### 13、文件锁单开进程

#### 14、哲学家就餐模型

#### 15、总结

### day15、libevent

### day16、xml json

