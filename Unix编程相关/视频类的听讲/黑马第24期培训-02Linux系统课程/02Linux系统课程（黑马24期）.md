## 内容

### day05、进程控制

#### 01、复习

#### 02、学习目标（20200227）

+ 进程相关的概念；
+ 进程控制函数：`fork(), getpid(), getppid()`
+ 进程控制指令：`ps, kill`
+ 执行其它程序的函数：`execl(), execlp()`
+ 孤儿进程、僵尸进程
+ 为了避免产生僵尸进程的函数：`wait(), waitpid()`

#### 03、进程和程序（20200307）

+ 程序：**编译好的二进制文件**。
+ 进程：**运行着的程序**。（从码农角度：运行一系列指令的过程；站在操作系统角度：分配系统资源【CPU和内存】的基本单位；）
+ 区别：
  + 程序占用磁盘，不占用系统资源
  + 进程占用系统资源
  + 一个程序对应多个进程；一个进程只对应着一个程序
  + 程序没有生命周期，进程有生命周期

#### 04、单道和多道程序设计（20200307）

+ 单道程序设计：DOS
+ 多道程序设计：
  + CPU把自己分若干个时间片，每个进程分时间片。【CPU处理是纳秒级，肉眼只能毫米级】
  + CPU在不同的进程间不断切换。
+ **微观上串行，宏观上并行**。

#### 05、进程的状态转化（20200227）

+ **MMU**（Memery Manage Unit）
+ **进程的状态**：运行、就绪、挂起、终止。
  + 就绪->运行（获得CPU）
  + 运行->挂起（缺少执行需要的资源或数据、主动失去CPU）
  + 其它任何状态都可以变成 终止态
  + 运行->就绪（时间片到了，被动失去CPU）
  + 挂起-就绪（获得非CPU的资源）

#### 06、MMU的作用（20200307）

+ 32位的话，就是2的32次方，4G的寻址空间。
+ **作用**：虚拟内存与物理内存进行映射；设置修改内存访问级别。
  + 0级最高（内核）
  + 3级（用户）
+ CPU先去读虚拟内存地址，MMU通过映射关系，找到对应的物理系统，再读取值。
+ **即使在用户空间虚拟地址是同一个值，映射的也是不同的空间，是独立的**。【内核是映射到同一块的，因为进程间需要交流】

#### 07、PCB的概念（20200228）

+ Linux的进程控制块是**`task_struct`结构体**。
  + `grep -rn "struct task_strct {"  /usr/`查找当前系统在哪个头文件
+ 重点掌握结构体的字段
  + 进程id
  + 进程状态
  + 进程切换时需要保存或恢复的寄存器
  + 描述虚拟地址空间的信息
  + 描述控制终端的信息
  + 当前工作目录（Current Working Directory）
  + umask掩码
  + 文件描述表，包含很多指向file结构体的指针
  + 和信号相关的信息
  + 用户id和组id
  + 会话（session）和进程组
  + 进程可以使用的资源上限（Resource Limit）
+ 光标停留在`{`上，在**vi的`%`能跳转到结构体的下一个括号**。--这个真没用过。
+ **`ulimit -a`命令，**查看所有的资源限制

#### 08、获取环境变量（20200307）

+ `char *getenv(const char *name);`
+ 用`env`命令，查看系统环境变量。格式是**key=value**，等号两边不能有空格。
+ `echo $PATH`：查看单个的环境变量。**PATH是可执行文件的搜索路径**。
+ **配置文件，一般在当前用户下创建etc目录**，比如`/home/itheima/etc`，*项目上也是这样的*。
+ `setenv()`去设置环境变量。
+ `.bashrc`里面加环境变量，用`export key=val`的方式配置到`.bashrc`里面。
+ [getenv.c]

#### 09、进程控制函数fork（20200228）

+ 创建一个新的进程：`pid_t fork(void);`
  + 返回值：失败返回-1，设置errno；成功的话，**有2次返回**，父进程返回**子进程的ID**，子进程返回**0**。
+ 示例：a.out进程，通过fork()后变成a.out进程和a.out子进程2个。
+ 获得当前进程ID，pid，`pid_t getpid(void);`
+ 获得当前父进程ID，`pid_t getppid(void);`
+ [fork.c]

#### 10、fork创建子进程（20200228）

+ [fork.c]接上面的

#### 11、进程控制的命令（20200307）

+ `ps aux` 【a是all，u是用户信息，x与a连用】
+ `ps ajx` 【j是进程组相关】，**可以追溯进程之间的血缘关系**。
+ `kill -l`查看，一般`kill -9`是用的是9号信号（SIGKILL）。**kill只是给进程发送一个信号，只不过通常发9号信号**。
+ [fork.c]单独写的

#### 12、创建n个子进程（20200229）

+ 实现：让一个父进程创建5个子进程[nfork.c]
  + **循环fork()后，子进程要break退出**。
+ `ps aux | grep a.out | grep -v grep | wc -l`,-v是去掉最后一个grep -color。

#### 13、循环创建n个子进程控制顺序（20200229）

+ 从操作系统来看，父子进程没有区别，无先后顺序。**自己不加控制，会不太稳定**
  + 父进程先结束，shell会把终端收回，子进程继续打印。
+ 

#### 14、上午回顾

#### 15、父子进程共享的内容（20200306）

+ [09fork.c]
  + `printf("bgein..")` 与`printf('begin..\n');`两者的区别，有了换行符，以行缓冲输出。
+ **父子相同处**：全局变量，data，text，栈，堆，环境变量，用户ID，宿主目录，进程工作目录，信号处理方式。
+ **父子不同处**：进程ID，fork返回值，父进程ID，进程运行时间，闹钟（定时器），未决信号集
+ **感觉是把父进程的0-3G给复制了**。（0-3G是以底往上的，最下面是0)。早期是这么设计的；
+ 早期指向物理内存不一样；后面最开始fork时是一样的。**进程ID是在PCB*，内核区。
+ **读时共享，写时复制**，是对物理内存的处理原则。

#### 16、父子进程不共享全局变量（20200306）

+ [shared.c]
+ **全局变量，也是读时共享，写时复制**。

#### 17、execlp函数介绍（20200302）

+ 作用：执行其他程序，以前用`system()`
+ `int execl(const char *path, const char *arg, ...
                         /* (char  *) NULL */);`
  + **需要带路径**。
+ ` int execlp(const char *file, const char *arg, ...
                         /* (char  *) NULL */);` 
  + 区别在于：执行程序的时候，使用PATH环境变量，执行的程序可以不用加路径（相对或绝对）。
  + file 是进程名（程序名），arg就是进程的参数；【要从agrv[0]开始】
  + **参数列表最后需要一个NULL作为结尾，哨兵。
  + 返回值：只有失败才返回。
+ 不是太懂的地方：
  + 执行`execlp("/bin/ls")`，就是把ls的代码段（txt区域）可替换到当前执行的进程中的代码段（txt区域）。
  + 大部分是不换的，只换.txt和.data区域。
+ [execl.c]

#### 18、exec函数规律（20200302）

+ 接上面的[execl.c]
+ **其它族相关的，自己写下**，*这部分可参考Kerrisk的chap27*。

#### 19、execl实现自定义程序（20200302）

+ **shell执行指令时，先fork()，用子进程去执行shell。**
+ 练习：
  + 用`execl执行自己的程序`
    + 浮点型错误：int a=0; int b=10/a;
    + 段错误：操作非法地址

#### 20、孤儿进程与僵尸进程（20200304）

+ 孤儿进程
  + 父亲死了，子进程被init进程领养。
+ 僵尸进程
  + 子进程死了，父进程没有回收子进程的资源（PCB）。**操作系统没有回收是想让父进程知道自己的子进程情况**。
+ [orphan.c]
  + 父进程死了后，`Ctrl+C`就不好使了
+ [zombie.c]
  + `ps aux|grep 进程名`出现 `z+`状态，或者`[a.out] <defunct>`就是僵尸进程。
+ **僵尸进程的资源回收**：只能把它的父进程杀死，让init进程领养，然后init会负责回收。

#### 21、wait函数简单使用和说明（20200304）

+ **子进程回收**，就是`wait()`和`waitpid()`，要知道子进程的死亡原因。
+ `pid_t wait(int* status)`
  + **status是传出参数**，是操作系统给出的值，是告诉你子进程的死亡原因。
  + 返回值：成功时返回终止的子进程ID；失败返回-1，设置errno。
+ wait的作用
  + 阻塞等待子进程死亡
  + 回收子进程资源
  + 查看死亡原因
+ [wait.c]
+ 子进程的死亡原因
  + 正常死亡WIFEXITED
    + 如果WIFEXITED为真，使用WEXITSTATUS得到退出状态；
  + 非正常死亡WIFSIGNALED
    + 如果WIFSIGNALED为真，使用WTERMSIGT得到杀死的信号是第几号

#### 22、wait回收并且查看死亡原因（20200304）

+ [wait.c]接上面

#### 23、waitpid回收子进程（20200304）

+ `ps -ajx`第2列看进程组ID，父进程id，就是组的id。
+ `pid_t waitpid()`
  + pid：
    + <-1，组id，
    + 等于-1的话，回收任意
    + 等于0的话，回收和调用进程组id相同组内的子进程
    + 大于0，回收指定的进程pid
  + options
    + 为0的话，与wait()相同，也会阻塞
    + 为WNOHANG，如果当前没有子进程退出的话，会立刻返回。
  + 返回值：
    + 如果设置了WNOHANG，那么如果没有子进程退出，返回0。
      + 如果有子进程退出，返回退出的pid，
    + 失败返回-1（没有子进程）。
+ [waitpid.c]
+ **这节还是需要再理解的**。

#### 24、用wait回收多个子进程

+ [nfork_wait.c]

#### 25、waitpid回收多个子进程 （20200306）

+ [nfork_waitpid.c]

#### 26、总结和作业



### day06、进程间通信

#### 1、内容回顾

#### 2、学习目标和IPC概念（20200317）

+ 学习目标
  + 使用pipe进行父子、兄弟进程间通信
  + 使用fifio进行无血缘关系的进程间通信
  + mmap函数的使用
  + mamp创建匿名映射区
  + mamp进行有血缘，无血缘关系的进程间通信
+ IPC概念
  + **内核提供了一块缓冲区**，用户区无法通信，只有内核区才能进行通信。（3G-4G区的buffer）。
+ IPC通信的方式有几种
  + pipe：管道（最简单的），就是匿名管道
  + fifio：有名管道
  + mmap：文件影射贡献IO--速度最快
  + 本地socket：最稳定
  + 信号：携带信息量最小
  + 共享内存：（项目1里会讲到？）进程创建后退了，其它进程也可以访问
  + 消息队列：
+ *迅雷下载就是进程间通信的例子*

#### 3、管道的概念（20200321）

+ `pipe()`
+ **通过在内核创建buf用于构建管道**，使用这个buf的两个进程必须有血缘关系。
  + **在子进程创建之前创建`pipe()`**
    +  父进程`pipe()`后对于两端都有操作权限，子进程也是一样的。
  + 管道：半双工通信
    + 单工：只能一个方向（比如广播）
    + 半双工：同一个时刻只能一方发（对讲机）
    + 全双工：同时发（打电话）

#### 4、管道通信举例1（20200322）

+ `pipe(int pipefd[2])`
  + pipefd读写文件描述符，0-代表读，1-代表写
  + 失败返回-1，成功返回0
+ [pipe.c]
  + **read()读设备是阻塞等待，读文件不是**。

#### 5、父子进程实现ps-grep命令（20200322）

+ 实现`ps aux|grep bash`功能

#### 6、ps-grep命令实现问题解决（20200322）

+ `grep bash`这种是匹配标准输入；`grep "bash"`也是一样滴
+ **父进程认为还有写端存在，就有可能还有人给发数据，继续等待**，保证同一个流向，读端读，写端关闭即可。
+ **要保证数据流向没有岔路**。

#### 07、管道的读写行为（20200323）

+ 读管道
  + 写端全部关闭--read读到0，相当于读到文件尾
  + 写端没有全部关闭
    + 有数据--read读到数据
    + 没有数据--read阻塞，**fcntl函数可以更改非阻塞**
+ 写管道
  + 读端全部关闭--产生一个信号SIGPIPE，程序异常终止
  + 写端没有全部关闭
    + 管道已满--write阻塞（读端一直不读；写端狂写）
    + 管道未满--write正常写入

#### 08、管道大小和优劣（20200323）

+ `ulimit -a`里的pipe大小，或者用`fpathconf()`函数来查看大小
+ 优点：
  + 简单
+ 缺点：
  + 只能有血缘关系的进程通信
  + 父子进程单向通信，如果需要双向通信，需要创建多根管道
+ **实现兄弟进程间通信**  `ps aux | grep bash`

#### 09、

#### 10、fifo实现通信写端（20200323）

+ FIFO有名管道，实现无血缘关系进程通信
  + **创建一个管道的伪文件**
+ `mkfifo`命令，**创建伪文件**，也可以是`mkfifo()`函数
+ 内核会针对fifo文件开辟一个缓冲区，操作fifo文件，可以操作缓冲区，实现进程间通信--**实际上就是文件读写**。

#### 11、fifo使用注意事项（20200324）

+ [fifo_r.c]
  + **open()阻塞了**，用`FIFOs`会被卡住。
+ open注意事项：
  + 打开fifo文件的时候，read端会阻塞等待write端open，write端同理，也会阻塞等待另外一端打开。

#### 12、上午内容回顾

#### 13、mmap映射开始（20200325）

+ 作用：**把文件中的某一段内容映射到内存**，就等同于操作内存。
+ 创建映射区`mmap()`
  + addr传NULL
  + length：映射区长度
  + port：
    + PORT_READ
    + PORT_WRITE
  + flags
    + MAP_SHARED 映射区是共享的【**对内存的修改会影响到源文件**】
    + MAP_PRIVATE 映射区是私有的
  + fd：文件描述符，open打开一个文件
  + offset：偏移量，（文件从哪开始取）
  + 返回值：
    + 失败：MAP_FAILED (void*) -1
    + 成功：返回可用的内存首地址
+ 释放映射区：`munmap()`
  + addr传mmap()的返回值
  + length：mmap()创建的长度
  + 返回值：
    + 成功返回0，失败返回-1

#### 14、mmap注意事项1（20200325）

+ 共有9问
+ 1、如果更改mem变量的地址，释放的时候munmap，传入mem还能成功吗？
  + `mem++`修改即可改变地址，**不能成功释放**
+ 2、如果对mem越界操作会怎么样？
  + `strcpy()`时，超过定义的8个时，但原始文件可能是大于8，或小于8的场景。**文件的大小对影射区操作有影响，尽量避免，文件本身的大小，超过定义的大小**，会写进数据。
+ 3、如果文件偏移量随便填个数会怎么样？
  + 随便填会报错，**offset必须是4k的整数倍**，比如4096。
  + 通过`stat `查看文件状态，**4096是文件的最小门槛**，哪怕没有用到4096，也是这么多。
+ 4、如果文件描述符先关闭，对mmap映射有没有影响？
  + 没有影响。**因为通道已经通了**
+ 5、open的时候，可以新创建一个文件来创建映射区吗？
  + `O_CREAT|O_TRUNC`，创建并且截断文件
  + **不可以用大小为0的文件创建**，要追加一行`ftruncate(fd,8);`
+ 6、open文件选择O_WRONLY，可以吗？
  + **不可以，Permission denied ）建立映射的过程，隐含了一次读操作**。
+ 7、当选择MAP_SHARED的时候，open文件选择O_RDONLY，port可以选择PORT_READ|PORT_WRITE吗？
  + **不可以，Permission denied **，因为PORT|WRITE，所以没有权限。**MAP_SHARED时，port的权限要小于，等于open的权限**。
+ 8、mmap什么情况下会报错？
  + **很多情况**
+ 9、如果不判断返回值会怎么样？
  + **必须判断返回值，否则死得很难看**

#### 15、mmap注意事项2（20200325）

+ 接上面：从第6个开始

#### 16、mmap实现父子进程通信（20200328）

+ 原理：**父子进程都拿到影射区的内存地址**，先创建映射区再fork。
+ [mmap_child.c]
  + **里面创建的fd没有实质作用，就引出个匿名映射**。
  + mmap里有个选项**`MAP_ANONYMOUS`**

#### 17、匿名映射（20200328）

+ [mmap_child_anonymous.c]
+ `head 06 文件名 > 新的文件名`，相当于拷贝了前6行。
+ **这是LINUX特有的2个宏**，在某些Unix里没有，**可以用`/dev/zero`这个文件**，号称聚宝盆，可以随意映射。
+ **`/dev/null`**是无底洞，一般错误信息，重定向这个文件中，就不会占用硬盘空间。

#### 18、mmap实现无血缘关系进程通信（20200328）

+ [w.c]
+ [r.c]

#### 19、mmap_MAP_SHared再次说明（20200328）

+ **进程之间要通信的话，必须是共享的**，不能设置为MAP_PRIVATE。
+ [mmap_child.c]里设置

#### 20、总结和作业

#### 21、信号的概念（20200328）

+ **信号，也是一种IPC机制**。Linux诞生时就有信号
+ 信号的特点（共性）
  + 1、简单
  + 2、不能携带大量信息
  + 3、满足某个特定条件才发送
+ 信号的机制
  + 进程B发送给进程B，**本质上是内核发送信号，内核进程处理**
+ 信号的默认处理方式
  + **要么捕获**，
  + 要么立即处理，
  + 要么忽视。
+ 信号的产生：
  + 按键产生：Ctrl+C，Ctrl+\
  + 调用函数 kill()，raise()，abort()
  + 定时器：alarm()，setitimer()
  + 命令产生：kill命令
  + 硬件错误：段错误，浮点型错误，总线错误，SIGPIPE
+ 信号的状态
  + 产生
  + 递达（信号到达并且处理完）
  + 未决（信号被阻塞了）
+ 信号的4要素
  + 编号
  + 事件
  + 名称
  + 默认处理动作（`man 7 signal`）
    + 忽略
    + 终止
    + 终止+Core
    + 暂停
    + 继续
+ `kill -l`可以看各种信号



### day07、信号

#### 01、内容复习

#### 02、作业说明

#### 03、信号的回顾（20200308）

+ **杀死进程，就是通过信号来产生，信号是内核产生和处理的**。
+ 信号四要素：
  + 编号
  + 名称
  + 事件
  + 默认处理动作（Term，Ign， Core，Stop，Cont）。 `man 7 signal` 终止，忽略，终止产生Core，暂停，继续
+ 信号的特点：
  + 简单
  + 不能携带大量信息
  + 特定条件下产生
+ **信号也叫软件产生的中断，有可能会有延迟**。
+ 信号的处理方式：
  + 执行默认动作（上面的5个）
  + 忽略
  + 捕捉
+ **9，19号信号不能捕捉，不能忽略，甚至不能阻塞**。

#### 04、学习目标（20200308）

+ 信号的基本概念
+ 信号相关的函数，信号集操作相关函数
+ **熟练掌握**信号捕捉函数signal()和sigaction()
+ **熟练掌握**使用信号完成子进程的回收。
  + *加上wait()，子进程退出的时候回收回来，不用傻等了*。--这个不是太熟悉，要学习一下。lionel。

#### 05、阻塞信号集，未决信号集信号产生（20200308）

+ **递达**：递送并且到达进程。
+ **未决**：产生和递达之间的状态。主要由于阻塞（屏蔽）导致该状态。
+ 集合理解为位图，**最大的就是31，从1号开始**，0号信号有特殊含义。
+ **未决信号集**：来了之后先把信号置为1，信号处理之后置为0。
+ **阻塞信号集**，用于影响**未决信号集**，一直阻塞的话，一直未决。
+ 信号的产生
  + 终端按键：`ctrl+C`
  + 硬件异常：非法内存访问
  + kill函数/命令产生信号：
  + 系统API产生信号：`int kill(pid_t pid, int sig);`
    + pid大于0，要发送的进程ID
    + pid等于0，代表当前调用进程组内所有进程
    + pid等于-1，代表有权限发送的所有进程
    + pid小于0，代表-pid对应的组内所有进程
    + sig对应的信号
+ **练习**：某个子进程把父进程杀死
  + [killfather.c]

#### 06、raise和abort（20200309）

+ [kill3.c]
+ `int raise(int sig)`自己给自己发送信号。
+ `abort()`自己给自己发一个SIGABRT的信号。
+ [raise_abort.c]

#### 07、alarm发送信号（20200309）

+ alarm
  + 定时给自己发送SIGALRM
  + 几秒后发送信号
  + 返回值：上次闹钟剩余的描述
  + 特别的，如果传入参数秒为0，代表取消闹钟

#### 08、setitimer使用（20200310）

+ 周期性的发送信号。
+ 原型
  + new_value 要设置的闹钟时间
  + old_value 原闹钟时间
+ **which的3种值，对应不同的处理信号**。
  + ITIMER_REAL，自然定时法，SIGALRM
  + ITIMER_VIRTUAL 计算进程执行时间 SIGVTALRM
  + ITIMER_PROF  进程执行时间+调度时间
+ [setitimer.c]
+ [setitimer2.c]

#### 09、setitimer实现alarm前（20200310）

+ [myalarm.c]

#### 10、setitimer实现alram后（20200310）

+ 接上面[myalarm.c]

#### 11、1秒数数（20200310）

+ [count.c]
+ 用`time ./a.out`来计算。
+ 用`time ./a.out >1.log`来看区别。`tail -f 1.log`
+ printf比1.log慢的原因；**printf是行缓冲的，重定向是字节缓冲**。

#### 12、上午内容回顾

#### 13、信号集的函数（20200311）

+ **信号集**：
+ `sigemptyset()`：清空set，变为0。
+ `sigfillset()`：填充set，变为1。
+ `sigaddset()`：添加某个信号到信号集
+ `sigdelset()`：从信号集中删除某个信号（变为0）
  + 以上return0表示成功。
+ `sigismemeber()`：是否为集合里的成员
  + 返回1代表signum在集合中。
+ 设置阻塞或解决阻塞信号集：`sigpromask()`
  + how
    + SIG_BLOCK：设置阻塞
    + SIG_UNBLOCK：解除阻塞
    + SIG_SETMASK：设置set为新的阻塞信号集
  + set传入的信号集
    + 上面的几个函数
  + oldset：旧的信号集，传出（便于恢复之前的状态）
+ 读取当前的未决信号集：`sigpending()`

#### 14、打印未决信号集（20200311）

+ 打印当前信号集的打印[sigpending.c]

#### 15、sigaction捕捉settimer产生信号（20200312）

+ 作用：
  + 防止进程意外死亡。
+ `signal()`--尽量避免使用
  + signum：要捕捉的信号
  + handler：要执行的捕捉函数指针，**函数应该声明void func(int);**。
+ `sigaction()`
  + signum：捕捉的信号
  + act：传入的动作  是个结构体`struct sigaction{};`
    + (*sa_handler)(int) //函数指针，**一般flag是0时**
    + (*sa_sigaction)//flag非0时，使用
    + sa_mask//执行捕捉函数期间，临时屏蔽的信号集
    + sa_flags; //一般填0 **SA_SIGINFO会使用第2个函数指针**
    + (*sa_restorer)(void);//无效
  + oldact：原动作，用于恢复现场
  + 返回值：成功返回0，失败返回-1
+ [sigaction.c]

#### 16、sigaction特性演示（20200312）

+ 默认PCB中有一个信号屏蔽字，信号捕捉期间是由sa_mask来决定。
+ XX信号捕捉函数执行期间，XX信号自动被屏蔽。
+ 阻塞的常规信号，产生多次只记录一次。
+ [sigaction_mask.c]

#### 17、信号的处理流程（20200309）

+ 用户状态：发生中断、异常
+ 内核状态：处理以上导演，定义了捕捉函数，就回到用户状态，然后通过`sys_sigreturn()`再回到内核态。

#### 18、利用SIGCHLD回收子进程（20200313）

+ 子进程在暂停或退出的时候会发送SIGCHLD信号，我们可以通过捕捉SIGCHLD信号来回收子进程，这样就不用等待`wait()`了。
+ [child_catch.c]

#### 19、SIGCHLD回收注意事项（20200313）

+ [child_catch.c] 接上，*这个最好能写个01，02这样的序列*。

#### 20、总结和作业



### day08、守护进程-线程

#### 01、内容回顾

#### 02、守护进程相关的概念（20200314）

+ **创建“进程组”，“会话”的概念，主要是便于管理**。

+ 进程组：
  + 1个父进程创建5个子进程，父进程就是进程组的组长。
  + 多个进程在同一个组，第一个进程默认是组长。
+ 会话：
  + 含有多个进程组。
  + **组长不可以创建创建会话，必须是组员创建**。
  + 注意事项：
    + 调用进程不能是进程组组长，该进程变成新会话首进程（session header）
    + 该进程成为一个新进程组的组长进程
    + 新会话丢弃原有的控制终端，该会话没有控制终端
    + 该调用进程是组长进程，则出错返回
    + 建立新会话时，先调用fork，父进程终止，子进程调用setsid。
+ **创建会话的步骤：**
  + 创建子进程，父进程去死，子进程自当会长。
+ `getsid()`和`setsid()`中的s表示session。
+ 守护进程
  + **与终端无关**，终端关闭，进程依然存在。
  + **原理就是**SIGHUP，通过1号信号来关闭相关进程。
  + **以d结尾的进程**，是守护进程，比如`systemd`，如果是`?`代表与终端无关。
  + **创建守护进程，最关键的一步是调用setsid函数创建一个新的session，并成为session Leader**。
+ **创建守护进程模型**
  + 1、创建子进程，父进程退出
  + 2、在子进程中创建新会话
  + 3、改变当前目录为根目录 （非必须），根目录没权限，用`$HOME`
  + 4、重设文件权限掩码（非必须），`umask`命令，当前进程的掩码
  + 5、关闭文件描述符（非必须），为了避免浪费资源
  + 6、开始执行守护进程核心工作
  + 7、守护进程退出处理程序模型（**一般不退出**）
  + **调试的时候，先不要杀死父进程，先用父进程执行核心工作，逻辑没问题了，再执行创建子进程，杀死父进程**。

#### 03、守护进程创建（20200314）

+ 创建一个守护进程（作业）：每分钟在$HOME/log/创建一个文件，程序名.时间戳

#### 04、守护进程扩展了解（20200314）

+ `nohup`可以阻塞1号进程。 即`nohup ./a.out &`  //&表示后台运行，SIGHUP
+ **通过nohup指令也可以达到守护进程创建的效果**。会让cmd收不到SIGHUP信号。

#### 05、线程有关的概念（20200315）

+ **线程**：轻量级的进程，本质仍是进程（在Linux下）
+ 进程：独立地址空间，有PCB
  + 一个进程默认就是一个线程，但可以有多个线程。**相当于合租**
+ 线程：有PCB，**没有独立的地址空间**。【线程就执行一个函数，所以就在stack上不共享。】
+ **Linux下：线程（最小的执行单位）；进程（最小分配资源单位，可看作只有一个线程的进程）**。
+ **进程是苦力，是真正干活的**。（车间是个进程的话；车间的员工就是线程）。
+ 1个CPU只有1核的话，多线程有没有用？**没有用，因为只有1个线程获得CPU**.
+ **内核实现都是通过clone函数实现的，所以从内核看没有区别**。线程所有操作函数pthread*是库函数，而非系统调用。
+ 多线程和多进程其实区别不大，**多线程通讯时节省了很多成本**，类unix系统早期没有线程的概念，引入自windows。【windows里玩得比较6】
+ 查看lwp号：`ps -Lf pid`

#### 06、线程的优点和缺点（20200315）

+ 线程共享资源
  + 文件描述符表
  + 每种信号的处理方式
  + 当前工作目录
  + 用户ID和组ID
  + 内存地址空间（.text/.data/.bss/heap/共享库）
+ **尽量不要信号和多线程一起使**，因为其中任何一个都已经很乱了。
+ 线程非共享资源
  + 线程Id
  + 处理器现场和栈指针（内核栈）
  + 独立的栈空间（用户空间栈）
  + errno变量
    + 用`perror()`不行了，**线程里要用`strerror()`才行**。
  + 信号屏蔽字
  + 调度优先级
+ 线程优、缺点
  + 优点： 提高程序并发性；占用资源小，开销小；数据通信、共享数据方便
  + 缺点：库函数，不稳定；调试、编写困难；对信号支持不友好
  + 优点相对突出，缺点均不是硬伤。**Linux下由于实现方法，导致进程、线程差别不是很大**。
+ 引入多线程的目的：**为了更好的使用CPU**。

#### 07、创建一个线程（20200315）

+  **pthread_开头的函数**，以`pthread_create()`为例，**编译和链接时要加上-lpthread**。
  + thread：线程id，传出参数
  + attr：线程的属性 **大多数时候不用**
  + 第三个参数 函数指针 void* func(void*)
  + arg：线程执行函数的参数
  + 返回值：成功返回0；失败返回errno。
+ **线程是个库函数，要加pthread**.
+ **`pthread_self()`用于获取当前线程id。**
+ `set -o vi` **快捷查找之前的命令**。 [关于set -o vi的使用](https://blog.csdn.net/cnsdlywei/article/details/81906730) --设置shell里vi的快捷键。
  + 设置后的vi的快捷键在shell中使用 
+ 在$HOME的.bashrc增加
  + `alias echomake='cat ~/bin/makefile.template>>makefile'`

#### 08、线程的退出（20200316）

+ [pthread_exit.c]
  + **这个地方只是退了，但没有看到返回值**，具体要一节代码展现。
+ 线程退出函数，线程退出注意事项
  + 在线程中使用pthread_exit
  + 在线程中使用return（**主控线程return代表退出进程**）
  + **exit代表退出整个进程**。
+ **关注一下pthread_exit()的参数**。

#### 09、线程的回收（20200316）

+ [pthread_rtn.c]
+ 不回收，就会变成**僵尸线程**。
+ `pthread_join()`
  + thread：创建的时候传出的第一个参数
  + retval：代表的传出线程的退出信息（代码中的return值）
+ **线程回收，也是阻塞等待回收**

#### 10、上午内容的回顾

#### 11、杀死线程（20200316）

+ [pthread_cancel.c]
+ `pthread_cancel()`参数是pthread_t
  + **线程是被取消的话，退出值就是-1**，因为`#define PTHREAD_CANCELD((void*)-1)`
  + 失败返回errno，成功返回0。
+ **如何没有cancel point的话，就没法杀死线程**。用`pthread_testcancel()`来强行设置取消点。

#### 12、线程分离（20200317）

+ **好处**：线程回收就不用自己管了，不需要用`pthread_join()`回收资源了。
+ `pthread_deatch(pthread_t thread)`

#### 13、线程属性设置分离（20200319）

+ [pthread_var.c]
  + **全局变量**
+ `pthread_equal()`判断两个线程是否相等
  + **在某个进程内是唯一的，但整个系统中并不是唯一的**。
+ [npthread.c]**创建多个线程**
+ **线程的分离状态（掌握）**
  + `pthread_attr_setdetachstate()`
    + attr init初始化的属性
    + detachstate的值
      + PTHREAD_CREATE_DETACHED **线程分离**
      + PTHREAD_CREATE_JOINABLE  **允许回收**
  + 初始化`pthread_attr_init()`
  + 销毁`pthread_attr_destory()`

#### 14、线程注意事项（20200320）

+ NPTL
  + `getconf GNU_LIBPTHREAD_VERSION`查看pthread版本
  + NPTL实现机制（posix）**Native POSIX Thread Library**
  + gcc指定 -lpthread
+ 线程使用注意事项
  + 主线程退出其它线程不退出，主线程应调用`pthread_exit`，return退出会进程退出。
  + 避免僵尸线程
    + pthread_detach
    + pthread_join
    + pthread_create指定分离属性
  + malloc和mmap申请的内存可以被其它线程释放（必然的，因为它们是共享的）
+ 创建多少个线程合适
  + **CPU核数 double一下后，再加2**

#### 15、总结和作业

#### 16、线程同步的概念（20200321）

+ （银行卡，存折）对应同一个账户；不同的人对分别（银行卡，存折）的操作，**得有先后顺序**，不然余额就乱了。
+ 同步概念
  + 数据库同步：两个或多个数据库内容保持一致
  + 文件同步：两个或多个文件夹里的文件保持一致
  + 编程中，**“同”**指协同、协助，互相配合。
+ 线程同步：
  + **同步即协同步调，按预定的先后次序运行**。
  + 一个线程发出某一功能调用时，在没有得到结果前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。
+ **解决同步的问题：加锁！**
+ 数据混乱原因：
  + 资源共享
  + 调度随机（意味着数据访问会出现竞争）
  + 线程间缺乏必要的同步机制**只能解决第3点**。

#### 17、mutex相关的函数（20200321）

+ [thr_write.c] *这个自己就没写*
+ `pthread_mutex_`开头的函数
+ `pthread_mutex_init`
  + `pthread_mutex_t *restrict`，**restrict约束该块内存区域对应的数据，只能通过后面的变量进行访问和修改**。
  + `pthread_mutexattr_`开头，**这个用不着**，传`NULL`即可。
+ **mutex是互斥量** -- 锁。
+ `pthread_mutex_lock()` 给共享资源加锁
  + mutex init初始化的锁
  + 如果未所，成功，给线程加锁；
  + 如果已锁，**阻塞等待**。
+ `pthread_mutex_destroy()` 摧毁锁
  + mutex 传入的锁
+ pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; **常量初始化**，可以不用`init`。

### day09、线程同步

#### 01、内容回顾

#### 02、学习目标

#### 03、互斥量的使用（20200329）

+ `pthread_mutex_开头的函数`
+ 互斥量的使用频繁：
  + 初始化
  + 加锁
  + 执行逻辑---操作共享数据
  + 释放锁
+ 注意事项：**加锁需要最小粒度，不要一直占用临界区**。
+ `pthread_mutex_trylock()`
+ [mutex_trylock.c]
  + **错误码的头文件`/usr/include/asm-generic/errno-bash.h`**

#### 04、死锁（20200329）

+ 锁了又锁（锁了2次）
  + 自己加了一次锁成功，又加了一次。
+ **交叉锁**（自己抢占了一个，又抢占对方的）
  + 解决办法：**每个线程申请锁的顺序要固定（或一致）*
  + 如果申请到一把锁，申请另外一把锁的时候申请失败，应该释放已经掌握的。
+ **互斥锁只是建议锁**，防君子不防小人。

#### 05、读写锁（20200329）

+ 与互斥量类似，但读写锁允许更高的并发性。其特性为：**写独占，读共享**。
+ **读的写的时候不改变数据，不用加锁，只有写的时候，才加锁**。
+ 读写锁特性：
  + **写的优先级高**
  + 多个读的时候才共享，但凡有写的时候需要锁
+ `pthread_rwlock_init()`
+ **读写锁只有一把**，有不同的状态
  + 未加锁
  + 读锁（读模式下加锁）
  + 写锁（写模式下加锁）
+ 读写锁场景练习：
  + 线程A写锁成功，线程B请求读锁
    + 线程B阻塞
+ *学到第5分钟*

#### 06、条件变量介绍和生产者和消费者模型

#### 07、上午内容回顾

#### 08、条件变量生产者消费者模型实现

#### 09、条件变量生产者消费者模型演示

#### 10、信号量的概念

#### 11、信号量实现生产者和消费者分析

#### 12、信号量实现生产者和消费者

#### 13、文件锁单开进程

#### 14、哲学家就餐模型

#### 15、总结

