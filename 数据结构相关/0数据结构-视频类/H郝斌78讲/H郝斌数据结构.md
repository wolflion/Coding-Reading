## 缘起



## 内容

### 一、基础知识（01-11）

### 二、线性表：数组和链表（12-29）

### 三、栈和队列（30-49）

#### 30、栈的定义（20200414）

+ 定义
  + 静态内存（栈中）分配内存；动态内存（堆中）分配。
    + **静态的，或者局部变量是以压栈或出栈的方式，分配内存的所以叫栈区**。
    + **动态内存，他们是以堆排列的方式分配的内存，所以叫堆区**
    + 堆和栈，是分配内存的方式不一样。
  + 一种可以实现“先进后出”的存储结构。
  + 栈类似于 箱子（先放去的，不能先取出来）；
+ 分类
+ 算法
+ 应用

#### 31、栈的分类（20200414）

+ 静态栈
  + 以数组为基本组成单元
+ 动态栈
  + 元素与元素之间不连续；以链表为基本组成单元
  + **去掉了链表的部分功能**，只能在头部进行插入和删除

#### 32、栈可以执行哪些操作（20200414）

+ 出栈
+ 压栈
+ *生产者，消费者*（以栈实现的）
	+ 生产就是push到栈里（相当于往框里放饼）
	+ 消费就是pop（从框里拿饼吃）

#### 33、栈程序演示

+ *未看呢*

#### 34、栈的日常具体应用（20200414）

+ 函数调用
	+ f(){k()} **靠压栈，出栈实现的**（执行完，就表示内存释放掉，就是出栈）
+ 中断
+ 表达式求值
	+ `3*2+5/2-4`(一个栈放数字；一个栈放操作符)
+ 内存分配
	+ 调用函数就是把函数所有的参数压入栈中
+ 缓冲处理
+ 迷宫

#### 35、什么是队列（20200411）

+ 讲**栈**的时候，其实说的还是链表，对于链表的某些功能去掉就是栈。
+ 数组实现的队列
+ **先进先出**

#### 36、队列的分类和链式队列伪算法的讲解（20200411）

+ 链式队列：**内部是链表**的操作；
  + **头部是front，尾部是rear**。
  + 入队（rear），出队（front）。
+ 静态队列
+ 栈的话：**队头是top；队尾是bottom**。
  + 压栈，出栈

#### 37、学习循环队列必须要弄清楚的7个问题概述（20200412）

+ 静态队列---用数组实现
+ 静态队列都必须是**循环队列**。
+ 循环队列的讲解：
  + 1、静态队列为什么必须是循环队列？
  + 2、循环队列需要几个参数来确定？
  + 3、循环队列的各个参数的含义
  + 4、循环队列入队列伪算法讲解
  + 5、循环队列出队列伪算法讲解
  + 6、如何判断循环队列是否为空
  + 7、如何判断循环队列是否已满

#### 38、静态队列为什么必须是循环队列？（20200412）

+ **front指向第一个元素；rear指向最后一个元素的下一个元素**；
  + 非循环队列（普通数组）时，入列和出列时，rear都是新增的，虽然有空间，但没法入列。**只能被使用一次**
  + **如果入列，出列，都是向上移动，只能增不能减**
+ **指针可以指向有效数组的下一个元素，但不能使用它，否则越界**。
+ 张利国《Java教材》

#### 39、循环队列需要几个参数来确定及其含义和讲解（20200414）

+ 需要2个参数，**不同场合有不同的含义**
  + 先记住以下情况，然后再慢慢体会
+ 队列初始化
  + front和rear的值都是零
+ 队列非空
  + front代表的是队列的第一个元素
  + rear代表的是队列的最后一个有效元素的下一个元素
+ 队列空
  + front和rear相等，但不一定是0.

#### 40、循环队列的各个参数的含义（20200414）

+ 队列初始化
  + front和rear的值都是零
+ 队列非空
  + front代表的是队列的第一个元素
  + rear代表的是队列的最后一个有效元素的下一个元素
+ 队列空
  + front和rear相等，但不一定是0.

#### 41、循环队列入队列伪算法讲解（20200414）

+ **尾部rear入列**，一般分两步：
  + 1、将值存入rear所代表的位置
  + 2、直接写`rear++`肯定是错误的；**应该是`rear=(rear+1)%数组的长度`**

#### 42、循环队列出队列伪算法讲解（20200414）

+ **头部front出队**，可以只有一步
  + `front=(front+1)%数组长度`

#### 43、如何判断循环队列是否为空（20200414）

+ **`rear==front`，则队列一定为空**

#### 44、如何判断循环队列是否已满

### 四、递归 （50-58）

#### 50、递归1：递归的定义和不同函数之间相互调程序举例（20200419）

+ 定义：一个函数自己直接或间接调用自己
+ **递归是用栈实现的**
+ 函数调用与栈的关系

#### 51、递归2 ：一个函数自己调自己 程序举例（20200419）

+ **要了解一下函数调用的本质**，之前好像看过一本书说过

#### 52、递归3：1+2+3+....+100之和用递归来实现（20200419）

+ 1、先求阶乘
  + `n!=n乘(n-1)!`
+ **思考一下：溢出的原理**

#### 53、递归4：布置作业_汉诺塔（20200419）

+ ABC3个柱子，A柱子上的盘子从小到大的摆放，n个盘子借助B移动到C上，要求
  + 1、1次只能移动一个盘子
  + 2、移动过程当中大盘子永远不能放在小盘子上面
+ **n个盘子要搞定，先搞定n-1个的盘子，一直到最后一个盘子**

#### 54、递归5：一个函数为什么可以自己调用自己（20200419）

+ **当多个函数相互调用时，按照“后调用先返回”的原则**，每调用一次，就在栈顶分配空间。

#### 55、递归6：递归必须满足三个条件（20200419）

+ 必须有一个明确的中止条件
+ 该函数所处理的数据规模必须在递减
+ 这个转化必须是可解的

#### 56、递归7：循环和递归的比较（20200419）

+ **理论上讲循环的问题，都可以用递归解决，但递归的问题，循环不一定能解决**。
+ 递归：
  + 优点：易于理解 **理解树的知识点**
  + 缺点：速度慢；存储空间大
+ 循环：
  + 优点：速度快，存储空间小
  + 缺点：不易理解

#### 57、递归8：汉诺塔

#### 58、递归9：递归的应用（20200419）

+ 走迷宫
+ 数和森林（二叉树里）就是以递归的方式定义的
+ 数和图的很多算法都是以递归来实现的
+ 很多数学公式就是以递归的方式定义的
  + 菲波拉契序列

### 五、



