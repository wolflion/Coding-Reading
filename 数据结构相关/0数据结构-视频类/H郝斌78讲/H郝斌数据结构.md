## 缘起



## 内容

### 一、基础知识（01-11）

#### 01、什么叫做数据结构（20200516）

+ 数据结构概述
  + 定义
    + 教材“严蔚敏，吴伟民”写的书。里面都是**伪算法**，没有具体的实现。
    + **高一凡**实现了严蔚敏的伪算法。
    + **黄国瑜**自己写的书；
    + **设计数据结构是为了把数据写到内存里**。我们如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器（内存）中，以及在此基础上为实现某个功能（比如查找某个元素，删除某个元素，对所有元素进行排序）而执行的相应操作，这个相应的操作也叫算法。
    + **个体怎么保存？；个体与个体之间的关系如何保存？**  数据结构=个体+个体的关系
    + 算法：对存储数据的操作；（狭义） **泛型是广义的算法**。
  + 算法
+ 预备知识
+ 模块一：线性结构
  + 连续存储（数组）
  + 离散存储（链表）
  + 线性结构的两种常见应用：（栈、队列）
  + 专题：递归（求1+2+...+100；求阶乘；汉诺塔；走迷宫）
+ 模块二：非线性结构
  + 树
  + 图
+ 模块三：查找与排序
  + 折半查找
  + 排序
    + 冒泡
    + 插入
    + 选择
    + 快速排序
    + 归并排序
+ Java中容器和数据结构相关知识
  + Interator接口
  + Map
    + 哈希表

#### 02、衡量算法的标准（20200516）

+ 算法：**解题的方法和步骤**
+ 衡量算法的标准：
  + 1、时间复杂度：大概程序要执行的次数，而非执行的时间。
    + **因为两台机器不一样，所以不能用执行的时间来衡量**。
  + 2、空间复杂度：算法执行过程中大概所占用的最大内存。
  + 3、难易程度
  + 4、健壮性

#### 03、数据结构的特点（20200516）

+ 数据结构的地位
  + 数据结构是软件中最核心的课程。
+ **栈内存**是压栈的方式分配内存的；**堆内存**是堆排序的方式分配的。【不同的分配算法决定的堆，栈】---重要
+ 数据库是数据结构的狭窄版。
+ 程序 = 数据的存储 + 数据的操作 + 可以被计算机执行的语言。

#### 04、预备知识_指针1（20200509）

+ **通过语言去实现伪算法**（语言实现还是难；伪算法理解起来还是简单点）

#### 05、预备知识_指针2（20200524）

+ 难与不难：
  + 如果有个知识，你不懂，别人跟你一解释，你就懂了（这个知识点可能本身是不难的），**但这个知识，你自己要想，你就永远想不通，这是个死知识点**（从这个角度看，这个知识点是最难的）。
  + 有些知识点，就算有人跟你讲，你也很难弄明白。（作者认为指针属于这种）
+ 指针的重要性：指针是C语言的灵魂。
+ 定义：
  + **地址：内存单元的编号**。 【CPU只能访问内存，不能访问硬盘】。
    + 从0开始的非负整数。
    + 范围：0--FFFFFFFF【0-（4G-1）】
  + CPU与内存的三根总线：（内存地址从0到4G-1）
    + 地址线：哪个地址（地址线是32位的，所以是4G-1，2的32次方）
    + 控制线：读/写/读写
    + 数据线：进行数据传输
  + 指针：指针就是地址，地址就是指针。
    + **指针变量**：是存放（内存单元地址）【就是内存单元编号】的变量。也是变量。**存放的不能是内存单元的内容**。
    + 普通变量前不能加*。
    + 常量和表达式前不能加&。
    + **指针的本质是一个操作受限的非负整数**。
+ 分类
  + 1、基本类型的指针
    + **变量不会连续分配**，在内存中找个空间即可。
    + **找i的地址发送给p，意味着p指向i。`*p就代表了i`，i代表什么，`*p`就代表什么。**
    + （1）p保存i的地址，p就指向了i。
    + （2）修改p的值不影响i的值，修改i的值不影响p的值
    + （3）`*p`就代表了i，因为p指向了i。
    + **p内存的释放：是指操作系统回收了对p所分配内存的控制权限**【里面的数据依旧存在】
    + 内存的基本划分单位是字节。1个字节是8位。**字节和编号是一一对应的**。每个字节都有一个唯一确定的编号，一个编号对应一个字节！**这个编号也叫地址**。
    + 一个系统所能管理的内存空间的大小取决于参与编号的二进制位数！**2的位数次方**，如2的16次方，2的32次方
  + 2、指针和数组的关系（一组数组）
    + 数组名
      + 一维数组名是个指针常量，它存放的是一维数组第一个元素的地址，它的值不能被改变
      + 一维数组名指向的是数组的第一个元素
    + 下标和指针的关系
      + a[i]<<==>>*(a+i)
      + 假设指针变量的名字为p，刚p+i的值是p+i*(p所指向的变量所占的字节数)
    + 指针变量的运算
      + 指针变量不能相加，不能相乘，不能相除
      + 如果两指针变量属于同一数组，则可以相减
      + 指针变量可以加减一整数，前提是最终结果不能超过指针
        + p+i的值是p+i*(p所指向的变量所占的字节数)
        + p-i的值是p-i*(p所指向的变量所占的字节数)
        + p++ <==> p+1
        + p-- <==> p-1
  + 如何通过 被调函数 修改 主调函数 中普通变量的值
    + （1）实参为相关变量的地址
    + （2）形参为以该类型的类型为类型的指针变量
    + （3）在 被调函数 中通过 *形参变量名 的方式就可以修改主函数中的
  + 软件运行与内存关系（垃圾数据）
    + 内存是在操作系统的统一管理下使用的！
    + 1、软件在运行前需要向操作系统申请存储空间，在内存空闲空间足够时，操作系统将分配一段内存空间并将外存中软件拷贝一份存入该内存空间中，并启动该软件的运行！
    + 2、在软件运行期间，该软件所占内存空间不再分配给其他软件。
    + 3、当软件运行完毕后，操作系统将回收该内存空间（注意：操作系统并不清空该内存空间中遗留下来的数据），以便再次分配给其他软件使用。
    + 综上所述：一个软件所分配到的空间中极可能存在着以前其他软件使用过后的残留数据，这些数据被称之为垃圾数据。**所以通常情况下我们为一个变量，为一个数据，分配好存储空间之后都要对该内存空间初始化！**。
  + 如何通过被调函数修改主调函数中一维数组的内容【如何界定】
    + 两个参数
    + 参数1：存放数组首元素的指针变量
    + 参数2：存放数组元素长度的整型变量

#### 06、所有的指针变量只占4个字节，用第一个字节的地址表示整个变量的地址（20200509）

+ 示例1

```cpp
#include <stdio.h>
int main(void)
{
    double *p;
    double x = 66.6;
    p = &x;  //x占8个字节，1个字节是8位；【1个字节，1个地址】
    
    double arr[3]={1.1,2.2,3.3};
    double *q;
    q = &arr[0];
    printf("%p\n",q);//%p实际就是以16进制输出
    q = &arr[1];
    printf("%p\n",q);
    
    return 0;
}
```

#### 07、如何通过函数修改实参的值（20200509）

+ 代码示例1

```cpp
#include <stdio.h>
void f(int *p); //前置声明
int main(void)
{
    int i=10;
    f(&i);  //想修改i的值，只能通过传地址  【其实可以传引用的吧】
    #if 0
    int *p = &i;// int *p; p=&i;
    printf("%p\n",p);
    f();
    printf("%p\n",p);
    #endif
    printf("i=%d\n",i);
    return 0;
}

void f(int *p)
{
    *p=99;
}
```

+ 代码示例2
  + **要想改写它的值，只需要改写它的地址即可**。

```cpp
#include<stdio.h>

void f(int *q);
void f1(int **q);
int main(void)
{
    int i = 9;
    int *p = &i; //int *p; p = &i; 等价于
    
    printf("%p\n",p);
    
    f(p);
    f1(p);//f函数修改p的值   【p虽然是个指针，但也是变量】
    printf("%p\n",p);
    
    return 0;
}

void f(int *q)
{
    q = (int *)0x000113;//不强转，只是个字符串；
}

void f1(int **q)
{
    *q = (int *)0x000113;
}
```

#### 08、结构体的使用概述（20200524）

+ 为什么会出现结构体？

  + 把Student的几种属性，融合在一起。
  + **结构体里只有属性，没有方法**，功能比类弱一些。**类更能完整的表示事物**（除了属性，还有方法）
  + 为了表示一些复杂的数据，而普通的基本类型变量无法满足要求。

+ 什么叫结构体？

  + **结构体**是用户根据实际需要，自己定义的复合数据类型。

+ 如何使用结构体？

  + 两种方式

  ```cpp
  struct Student st = { 1000, "zhangsan", 20 }; 
  struct Student *pst = &st;
  //1
  st.sid;
  //2
  pst->sid;//表示　pst所指向的结构体变量中的sid成员。
  ```

  

+ 注意事项

  + 1、结构体变量，不能加减乘除，但可以相互赋值
  + 2、普通结构体变量和结构体指针变量，作为函数传参的问题

#### 09、malloc()动态分配内存概述（20200510）

+ 示例1：

```cpp
#include <stdio.h>
#include <malloc.h>
int main(void)
{
    //这个5，不能改变
    int a[5]={4,10,2,8,6}; //静态数组，没有用malloc()分配
    
    int len;
    printf("请输入你需要分配的数组的长度：len = ");
    scanf("%d",&len);
    //int类型变量，就取 int类型的sizeof()
    //malloc()返回的是第一个字节的地址，可以把8字节当1个变量，也能把4字节当1个变量 【无意义的地址，void* 的干地址】
    int *pArr = (int *)malloc(sizeof(int) * len); //4*5,向操作系统请求分配20个字节大小的空间，拿到这个空间的控制权限】
    
    *pArr = 4; //类似于 a[0]=4;
    pArr[1] = 10; //类似于a[1]=10;
    
    printf("%d %d",*pArr,pArr[1]);
    
    //我们可以把pArr当作一个普通数组来使用
    for(int i=0;i<len;++i)
    {
        scanf("%d",&pArr[i]);
    }
    
    for(i=0;i<len;++i)
    {
        printf("%d\n",*(pArr+i));
    }
    
    free(pArr);//把pArr所代表的动态分配的20个字节的内存释放
    
    return 0;
}
```

#### 10、跨函数使用内存讲解及其示例（20200525）

+ g()调用f()的过程中，f函数分配了内存，但g函数里一般不能用，但本节是想的是如何引用的。**用动态分配就能解决了**
+ 代码1

```cpp
#include<stdio.h>
int f();
int main(void)
{
    int i = 10;
    i = f();
    printf("i=%d\n",i); //i输出20
}

int f()  //f调用完毕，j就没有了。
{
    int j = 20;
    return j;
}
```

+ 下列程序中，能够通过调用函数fun，使main函数中的指针变量p指向一个合法的整型单元的是

```cpp
A) main()
{
    int *p; //没有合法值，只是个垃圾数据
    fun(p);  //error，这里要传地址才行
    ...
}

int fun(int *p)
{
    int s;  //这个s只是个局部变量，会释放掉。
    p = &s;
}

B) main()
{
    int *p;
    func(&p);
    ...
}

int fun(int **p)
{
    int s;  //这个s只是个局部变量，会释放掉。
    p = &s;
}

C) //这个是对的
#include<stdlib.h>
main()
{
    int *p;
    func(&p);
    ...
}

int fun(int **p)
{
    *p=(int*)malloc(4);//这里没有free()，所以没有释放。
}

D)
#include<stdlib.h>
main()
{
    int *p;
    func(p); //没加取地址符，这是啥套路? 
    ...
}

int fun(int *p)
{
    *p=(int*)malloc(sizeof(int));
}
```

#### 11、复习（20200530）

+ 数据结构研究**数据存储**的问题；
  + 个体的存储
  + 个的关系存储
+ **算法**：对存储数据的操作 

### 二、线性表：数组和链表（12-29）

#### 12、连续存储数组的算法演示_1  （20200510）

+ **线性结构**：把所有的结点（元素）用一根直线穿起来。
  + 连续存储【数组】
  + 离散存储【链表】--**离散**是个数学的概念
+ 栈和队列是 **线性结构**的应用。
+ 连续存储【数组】
  + 1、什么叫数组
    + 元素类型相同，大小相等
    + `int a[10];`
    + `int *pArr = (int *)malloc(sizeof(int) * len);`
  + 2、数组的优缺点

#### 13、连续存储数组的算法演示_2  （20200510）

+ **看懂一个程序的步骤**：
  + （1） 说出流程
  + （2）每个语句的功能
  + （3）
+ 要使用一个函数
  + （1）初始化条件
  + （2）各个参数的含义
  + （3）操作后要达到的功能
+ 数组不需要建（直接malloc就行），链表需要建。

#### 14、链表的重要性（20200511）

+ 树、图就会用到链点。
+ 线性表：1点->1点；树：1点->n点；图：n点->n点

#### 15、typedef的用法（20200511）

+ 简单的示例

```cpp
#include <stdio.h>

typedef int ZHANGSAN; //为int再重新多取一个名字,ZHANGSAN等价于int

typedef struct Student
{
    int sid;
    char name[100];
    char sex;
}ST;//为已有的struct Student{};重新取个名字ST

int main(void)
{
    int i=10;//等价于ZHANGSAN i = 10;
    ZHANGSAN j = 20;
    printf("%d\n",j);
    struct Student st;
    struct Student *ps = &st;
    
    ST st2;
    st2.sid=200;
    reutrn 0;
}
```

+ 复杂的示例

```cpp
#include <stdio.h>

typedef struct Student
{
    int sid;
    char name[100];
    char sex;
}*PST; //PST等价于 struct Student * 【类型替换】

int main(void)
{
    struct Student st;
    PST ps = &st;  //加p意味着 是个指针
    ps->sid = 99;
    printf("%d\n",ps->sid);
    
    reutrn 0;
}
```

+ 第3个示例，typedef后面写了两个。

```cpp
#include <stdio.h>

typedef struct Student
{
    int sid;
    char name[100];
    char sex;
}*PSTU,STU; //等价于ST代表了struct Student， PST代表了 struct Student *

int main(void)
{
    STU st;//相当于 sturct Stuent st;
    PSTU ps = &st; //相当于struct Student *ps = &st;
    ps->sid = 99;
    printf("%d\n",ps->sid);
    
    reutrn 0;
}
```

#### 16、链表的定义（20200512）

+ 离散存储【链表】
  + 不连续（任何一点到任何一点，都有间距，但能被计算出来），离散的概念
+ **链表的定义**：
  + 不连续存储（结点与结点不相连）；n个节点离散分配
  + 彼此通过指针相连
  + 每1个节点前面只有1个结点，后面也只有1个结点
  + 第1个节点前面没有节点，最后1个节点后面没有节点（首节点没有节驱节点，尾节点没有后续节点。
+ 链表的分类：
+ 链表的算法：
+ 链表的优缺点：
+ 专业术语
  + 首节点：4个节点，存放4个数据。 **有效数据的第1个节点**，（第1个存放有效数据的节点）
  + 尾节点：最后一个存放有效数据的节点
  + **头结点**
    + 在首节点的前面，加了一个头结点（**头结点里没有存放有效数据；没有存放头结点的个数**）
    + 主要用于**方便链表操作**，才加了一个没有意义的头结点，可以不加。
    + 头结点的数据类型和有效元素的数据类型是一样的。
  + 头指针
    + **指向头结点的指针变量**
  + 尾指针
    + **指向尾结点的指针变量**

#### 17、如果希望通过一个函数来对链表进行处理，我们至少需要接受链表的哪些参数（20200512）

+ **确定一个链表，需要几个参数**（1个）
  + 不要长度（个数）；有了头节点就可以不要首节点；尾节点也不是必须，一个个往后找也能找到；**重要的是思考过程**。
  + **只需要一个头指针**就可以了。【指针只要4个字节；存放头结点的话，就需要存放相应的数据类型（不同链表的类型还不一样）】
+ **确定一个数组，需要几个参数**
  + 3个（有效元素的个数，长度，首地址）

#### 18、每一个链表节点的数据类型该如何表示的问题（20200512）

+ 结点的生成示例
  + **一个结点有2部分（指针域，数据域）**。【结点通过数据类型表示，有两个成员】
  + 一个结点，第1部分要存放有效数据，第2部分是指针（指向第2个结点）
  + **第一个结点的指针域是指向第2个结点的整体信息**。【结构体里的指针域，指向了结构体类型。】**结构体里的成员，指向了结构体变量**。

```cpp
#include <stdio.h>
//造一个结点类型
typedef struct Node
{
    int data;//数据域  【这个数据域，可以无比复杂，只不过这里是用int】
    struct Node *pNext;//指针域   【里面指针域类型 是结构体类型】
}NODE, *PNODE;//NODE是 struct Node类型； PNODE是struct Node*类型

int main(void)
{
    return 0;
}
```

#### 19、链表的分类（20200512）

+ 单链表
+ 双链表
  + **每个结点有2个指针域**。
  + 都是指向**整体**，而不是结构体的指针域。
+ 循环链表
  + 能通过任何一个节点找到其它所有节点。
+ 非循环链表

#### 20、非循环单链表插入节点伪算法讲解（20200512）

+ 算法
  + 遍历
  + 查找
  + 清空
  + 销毁
  + 求长度
  + 排序
  + 删除节点
  + 插入节点
+ 插入节点伪算法
  + 初始条件：p指向原有链表中的某个结点；现在有一个新的结点q
  + 想让q指向的节点，放到p指向节点的后面，最终效果是**p指向q**
+ 插入节点代码

```cpp
1、p指向的结构体变量的指针域  p->pNext;
2、r = p->pNext;//先找个临时变量存一下
3、p->pNext = q;
4、q->pNext = r;


//第2种写法
q的指针域，写向p指向的结构体变量的指针域
q->pNext = p->pNext;
p指针域指向q
p->pNext = q;

q只是个指针变量，本身存放的是地址，是结点的地址。

```

#### 21、删除非循环单链表节点伪算法的讲解（20200516）

+ 删除：`p->pNext = p->pNext->pNext;`  **这个会导致内存泄露**，有个结点没有释放。
+ 正确的写法

```cpp
r = p->pNext;
p->pNext = p->pNext->pNext;
free(r);//不能free(p-pNext)，这样会导致删除后面的所有
//free p;  //是删除p指向结点所占的内存，不是删除p本身所占内存。p本身是栈内存。p所指向的是堆内存。
```

#### 22、学习数据结构的目的和要达到的要求（20200510）

+ 对数据结构有基本概述 
+ **对链表相关代码要能敲出来**

#### 23、复习（20200510）

+ **学数据结构一定要把链表搞清楚**。
+ 只有两种结构：
  + 线性结构（用一个线能串起来的）
    + 顺序存储
    + 离散存储
  + 非线性结构。

#### 24、链表创建和链表遍历算法的演示（20200517）

+ list.cpp

```cpp
#include<stdio.h>
#include<malloc.h>
#include<stdlib.h>

typedef struct Node
{
	int data; //数据域
	struct Node* pNext; //指针域
}NODE,*PNODE; //NODE等价于struct Node，PNODE就是 struct Node*

PNODE create_list();
void traverse_list(pHead);

//分配内存

int main()
{
    PNODE pHead = NULL;//等价于struct NODE*
    pHead = create_list();  //创建一个非循环单链表，并将该链表的头结点的地址赋给pHead
    traverse_list(pHead);//遍历
	return 0;
}

void f()
{
    int i = 10;
    int *p = (int*)malloc(100);//函数消亡后，p本身不存在了，但分配的100个字节的内存还是在的
}

PNODE create_list()
{
    int len;//用来存放有效节点的个数
    int val;  //用来临时存放用户输入的结点的值
    
    //先生成头结点 【分配了一个不存放有效数据的头结点】
    PNODE pHead = (PNODE)malloc(sizeof(NODE));
    if(NULL == pHead)
    {
        printf("分配失败，程序终止！");
        exit(-1);
    }
    
    //pTail指向尾结点
    PNODE pTail = pHead;
    pTail->pNext = NULL;
    
    printf("请输入您需要生成的链表节点的个数：len = ");
    scanf("%d",&len);
    
    for(int i=0;i<len;++i)
    {
        printf("请输入第%d个节点的值：",i+1);
        scanf("%d",&val);
        
        //每次分配一个pNew的新结点
        PNODE pNew = (PNODE)malloc(sizeof(NODE));
        if(NULL == pNew)
        {
            printf("分配失败，程序终止！");
            exit(-1);
        }
        pNew->data = val;
        //把新生成的pNew挂到头结点指向链点的最后，而不是pHead的结点后面
        //有一个尾指针pTail永远指向最后面
        #if 0 
        //这个写法有问题
        pHead->pNext = pNew;
        pNew->pNext = NULL;
        #endif
        pTail->pNext = pNew;
        pNew->pNext = NULL;
        pTail = pNew;
    }
    
    return pHead;
}

void traverse_list(pHead)
{
    //a[i]等价于*(a+i)，因为数组的地址是连续的
    //先定义p，指向第1个有效节点，然后再往后移
    PNODE p = pHead->pNext;  //【要借助临时变量】
    while(NULL != p) //我用的是if()，用错了
    {
        printf("输出p的值: %d ",p->data);
        p = p->pNext;
    }
    printf("\n");
}
```

#### 25、判断链表是否为空 和 求链表长度算法的演示（20200517）

+ 判空&求长度

```cpp
bool is_empty(PNODE pHead);  //链表一般不判满的情况
{
    if(pHead->pNext == NULL)
        return true;
    else
        return false;
}

int length_list(PNODE pHead);
{
    int len= 0;
    PNODE p = pHead->pNext;
    while(p!= NULL)
    {
        ++len;
        p = p->pNext;
    }
    return len;
}
bool insert_list(PNODE,int,int);//链表，插入位置，插入的值
bool delete_list(PNODE,int,int*);//把删除的值给传出来
void sort_list(PNODE);
```

#### 26、通过链表排序算法的演示 再次详细讨论到底什么是算法以及到底什么是泛型【重点】

+ 算法
  + 狭义的算法是与数据的存储方式密切相关的
  + 广义的算法是与数据的存储方式无关的
  + 泛型：
    + 利用某种技术达到的效果就是：不同的存储方式，执行的操作时一样的。
  + **数组排序时用了`++`，但链表里没有`++`，这样可以用“函数重载”的方式来实现`++`运算符的操作**。有时候`p++`可以理解为p调用++函数，内部实现为`p=p->pNext;`

+ 排序

```cpp
void sort_list(PNODE pHead)
{
    #if 0
    //数组的比较（冒泡）
    int i,j,t;
    for(i=0;i<len-1;++i)  //6个元素的话，比较5次。
    {
        for(j=i+1;j<len;++j)
        {
            if(a[i]>a[j])
            {
                t = a[i];
                a[i]=a[j];
                a[j]=t;
            }
        }
    }
    #endif
    //数组和链表，都属于线性结构 【算法是一样的】
    
    int i,j,t;
    int len = 10;//获取链表的长度，这里写成固定值了
    PNODE p,q;
    for(i=0,p=pHead->pNext;i<len-1;++i,p=p->pNext)
    {
        for(j=i+1,q=p->pNext;j<len;++j,q=q->pNext)
        {
            if(p->data > q->data)
            {
                t = p->data;
                p->data = q->data;
                q->data = t;
            }
        }
    }
    return;
}
```

#### 27、如何学习算法自己的一些感想（20200517）

+ 看到一个算法，**自己想不通，搞不定很正常**，属于数学上的公式或定理。（**把人家答案看懂就行**）
+ **看懂程序3步**
  + 流程（就是步骤）
  + 每个语句的功能
  + 试数
+ **遇到部分不是很懂的情况，就暂时先背会，然后再不断琢磨**。

#### 28、链表插入和删除算法的演示（20200517）

+ 插入

```cpp
//在pHead所指向链表的第pos个节点的前面插入一相新的结点，该结点的值是val，并且pos的值是从1开始的
bool insert_list(PNODE pHead,int pos int val)
{
    //链表不存在满的情况，满不满就不需要判断
    //先求出长度，再与pos进行比较
    int i = 0;
    PNODE p = pHead;
    while(NULL != p && i<pos-1)
    {
        p = p->pNext;
        ++i;
    }
    if(i>pos-1 || NULL == p)
        return false;
    
    PNODE pNew = (PNODE)malloc(sizeof(NODE));
    if(NULL == pNew)
    {
        printf("动态分配内存失败！\n");
        exit(-1);
    }
    pNew->data = val;
    
    PNODE q = p->pNext;
    p->pNext = pNew;
    pNew->pNext = q;
    
    return true;
}
```

+ 删除

```cpp
//想删除第5个，就要找到第4个。【待删除元素的前1个节点】
bool delete_list(PNODE pHead,int pos int *val)
{
    int i = 0;
    PNODE p = pHead;
    while(NULL != p->pNext && i<pos-1)
    {
        p = p->pNext;
        ++i;
    }
    if(i>pos-1 || NULL == p->pNext)
        return false;
    
    PNODE q = p->pNext;
    *pVal = q->data;
    
    p->pNext = p->pNext->pNext;
    free(q);
    q = NULL;
    
    return true;
}
```

#### 29、复习（20200530）

+ 数据结构是专门研究数据存储的问题。
+ 数据的存储包含两方面：
  + 个体的存储
  + 个体关系的存储
+ 广义的讲：数据结构既包括数据的存储也包括数据的操作。
  + 对存储数据的操作就是算法。
+ 狭义算法是对存储数据的操作。
+ 广义算法：算法和数据的存储方式无关。（**这就是泛型思想**）
  + 模板
  + 运算符重载
  + 指针
+ 数据的存储结构有几种
  + 线性（用一根线把所有结点都串起来）
    + 连续存储（数组）
      + 优点：存取速度很快
      + 缺点：插入删除元素慢；空间通常有限制；事先必须知道数组的长度；需要大块的连续内存块；
    + 离散存储（链表）
      + 优点：空间没有限制；插入删除元素速度快；
      + 缺点：存取速度很慢
    + 线性结构的应用：栈和队列
  + 非线性
    + 树
    + 图

### 三、栈和队列（30-49）

#### 30、栈的定义（20200414）

+ 定义
  + 静态内存（栈中）分配内存；动态内存（堆中）分配。
    + **静态的，或者局部变量是以压栈或出栈的方式，分配内存的所以叫栈区**。
    + **动态内存，他们是以堆排列的方式分配的内存，所以叫堆区**
    + 堆和栈，是分配内存的方式不一样。
  + 一种可以实现“先进后出”的存储结构。
  + 栈类似于 箱子（先放去的，不能先取出来）；
+ 分类
+ 算法
+ 应用

#### 31、栈的分类（20200414）

+ 静态栈
  + 以数组为基本组成单元
+ 动态栈
  + 元素与元素之间不连续；以链表为基本组成单元
  + **去掉了链表的部分功能**，只能在头部进行插入和删除

#### 32、栈可以执行哪些操作（20200414）

+ 出栈
+ 压栈
+ *生产者，消费者*（以栈实现的）
	+ 生产就是push到栈里（相当于往框里放饼）
	+ 消费就是pop（从框里拿饼吃）

#### 33、栈程序演示

+ *未看呢*

#### 34、栈的日常具体应用（20200414）

+ 函数调用
	+ f(){k()} **靠压栈，出栈实现的**（执行完，就表示内存释放掉，就是出栈）
+ 中断
+ 表达式求值
	+ `3*2+5/2-4`(一个栈放数字；一个栈放操作符)
+ 内存分配
	+ 调用函数就是把函数所有的参数压入栈中
+ 缓冲处理
+ 迷宫

#### 35、什么是队列（20200411）

+ 讲**栈**的时候，其实说的还是链表，对于链表的某些功能去掉就是栈。
+ 数组实现的队列
+ **先进先出**

#### 36、队列的分类和链式队列伪算法的讲解（20200411）

+ 链式队列：**内部是链表**的操作；
  + **头部是front，尾部是rear**。
  + 入队（rear），出队（front）。
+ 静态队列
+ 栈的话：**队头是top；队尾是bottom**。
  + 压栈，出栈

#### 37、学习循环队列必须要弄清楚的7个问题概述（20200412）

+ 静态队列---用数组实现
+ 静态队列都必须是**循环队列**。
+ 循环队列的讲解：
  + 1、静态队列为什么必须是循环队列？
  + 2、循环队列需要几个参数来确定？
  + 3、循环队列的各个参数的含义
  + 4、循环队列入队列伪算法讲解
  + 5、循环队列出队列伪算法讲解
  + 6、如何判断循环队列是否为空
  + 7、如何判断循环队列是否已满

#### 38、静态队列为什么必须是循环队列？（20200412）

+ **front指向第一个元素；rear指向最后一个元素的下一个元素**；
  + 非循环队列（普通数组）时，入列和出列时，rear都是新增的，虽然有空间，但没法入列。**只能被使用一次**
  + **如果入列，出列，都是向上移动，只能增不能减**
+ **指针可以指向有效数组的下一个元素，但不能使用它，否则越界**。
+ 张利国《Java教材》

#### 39、循环队列需要几个参数来确定及其含义和讲解（20200414）

+ 需要2个参数，**不同场合有不同的含义**
  + 先记住以下情况，然后再慢慢体会
+ 队列初始化
  + front和rear的值都是零
+ 队列非空
  + front代表的是队列的第一个元素
  + rear代表的是队列的最后一个有效元素的下一个元素
+ 队列空
  + front和rear相等，但不一定是0.

#### 40、循环队列的各个参数的含义（20200414）

+ 队列初始化
  + front和rear的值都是零
+ 队列非空
  + front代表的是队列的第一个元素
  + rear代表的是队列的最后一个有效元素的下一个元素
+ 队列空
  + front和rear相等，但不一定是0.

#### 41、循环队列入队列伪算法讲解（20200414）

+ **尾部rear入列**，一般分两步：
  + 1、将值存入rear所代表的位置
  + 2、直接写`rear++`肯定是错误的；**应该是`rear=(rear+1)%数组的长度`**

#### 42、循环队列出队列伪算法讲解（20200414）

+ **头部front出队**，可以只有一步
  + `front=(front+1)%数组长度`

#### 43、如何判断循环队列是否为空（20200414）

+ **`rear==front`，则队列一定为空**

#### 44、如何判断循环队列是否已满

### 四、递归 （50-58）

#### 50、递归1：递归的定义和不同函数之间相互调程序举例（20200419）

+ 定义：一个函数自己直接或间接调用自己
+ **递归是用栈实现的**
+ 函数调用与栈的关系

#### 51、递归2 ：一个函数自己调自己 程序举例（20200419）

+ **要了解一下函数调用的本质**，之前好像看过一本书说过

#### 52、递归3：1+2+3+....+100之和用递归来实现（20200419）

+ 1、先求阶乘
  + `n!=n乘(n-1)!`
+ **思考一下：溢出的原理**

#### 53、递归4：布置作业_汉诺塔（20200419）

+ ABC3个柱子，A柱子上的盘子从小到大的摆放，n个盘子借助B移动到C上，要求
  + 1、1次只能移动一个盘子
  + 2、移动过程当中大盘子永远不能放在小盘子上面
+ **n个盘子要搞定，先搞定n-1个的盘子，一直到最后一个盘子**

#### 54、递归5：一个函数为什么可以自己调用自己（20200419）

+ **当多个函数相互调用时，按照“后调用先返回”的原则**，每调用一次，就在栈顶分配空间。

#### 55、递归6：递归必须满足三个条件（20200419）

+ 必须有一个明确的中止条件
+ 该函数所处理的数据规模必须在递减
+ 这个转化必须是可解的

#### 56、递归7：循环和递归的比较（20200419）

+ **理论上讲循环的问题，都可以用递归解决，但递归的问题，循环不一定能解决**。
+ 递归：
  + 优点：易于理解 **理解树的知识点**
  + 缺点：速度慢；存储空间大
+ 循环：
  + 优点：速度快，存储空间小
  + 缺点：不易理解

#### 57、递归8：汉诺塔

#### 58、递归9：递归的应用（20200419）

+ 走迷宫
+ 数和森林（二叉树里）就是以递归的方式定义的
+ 数和图的很多算法都是以递归来实现的
+ 很多数学公式就是以递归的方式定义的
  + 菲波拉契序列

#### 59、线性结构总复习 2线性结构和非线性结构关系  3栈队列链表数组之间的关系【重点】

### 五、树（60-

+ 树和图，主要讲伪算法。

#### 60、树的定义（20200520）

+ 树的定义：
  + **以递归定义**，有且只有一个称为根的节点，有若干个互不相交的子树，这些子树本身也是一棵树。
  + 作者的定义：（1）树是由节点和边组成；（2）每一个节点只有1个父节点但可以有多个子节点。（3）有一个结点例外，该节点没有父节点，此节点称为根节点。
+ 树的分类：
+ 树的操作：
+ 树的应用：

#### 61、树的专业术语解释（20200520）

+ 节点：
+ 父节点：
+ 子节点：**下面的所有节点**
+ 子孙：
+ 堂兄弟：（亲兄弟） 两个有区别
+ **深度**：树中节点的最大层次  【从根节点到最底层结点的层数】**根节点是第1层**。
+ 叶子节点：**没有子节点的节点**
+ 非终端节点：实际就是非叶子节点
+ **度**：子节点的个数。degree  【树的度】就是最大那个度。

#### 62、树的分



