## chap08、树（205/364）

### 0、课前秀

+ 需要掌握**递归**知识
+ 如果没点基础，看文字描述有点晦涩，不如看图和代码来得直观，更容易理解。

### 1、基本概念与运算

#### 1.1数的几个基本术语

+ **树**：树的定义是递归的。
  + 有且仅有一个称作根的结点
  + 其余的结点可分为m（m>=0）棵互不相交的有限集合T1，T2，...，Tn，其中每个集合又都是一棵对，并称其为根的子树。
+ 结点的**度**：每个结点具有的子树数。
+ 树的**度**：结点度的最大值。
+ 结点的**层数**：树具有一种层次结构。
+ 树的**深度（高度）**：树中结点的最大层数
+ **森林**：0个或多个不相交的树的集合

#### 1.2、树的表示

+ 树形
+ 文氏图
+ 凹入表
+ 嵌套括号

### 2、二叉树

#### 2.1、二叉树的几个基本术语

+ 二叉树：或者为空集，或者是由一个根结点及两棵不相关的数
+ **满二叉树**：树中的每一层都是满的。**当第i层的结点是2的i次方-1时，表第i层是满的**。
+ **完全二叉树**：除最后一层，其余层都是满的，并且最后一层或者是满的，或者是右边缺少连续若干个结点。

#### 2.2、二叉树的存储

+ （1）顺序存储

  + 构造一个满二叉树，分配存储空间，没有的地方填`0`。

+ （2）链接存储

  + 结点中设置**三个域**，值域，左指针域，右指针域。

  + ```cpp
    typedef struct bnode
    {
        ElemType data;
        //分别存储左孩子和右孩子结点（即左右子树的根结点）的存储位置（即指针）
        struct bnode *left,*right;
    }btree;
    ```

+ （3）线索二叉树

  + 解决：**链接存储中无左子树或右子树的结点的left域或right域为空，浪费存储空间**的问题。

  + 在结点的空指针域中存放的该结点在某次遍历次序下的前驱结点或后续结点的指针 叫做 **线索**。

  + 对一棵二叉对中的所有结点的空指针域按照某种遍历次序加线索的过程 叫做 **线索化**。

  + ```cpp
    typedef struct tnode
    {
        ElemType data;
        int ltag,rtag;// ltag和rtag只能取值0或1
        struct tnode *left,*right;
    }tbtree;
    ```

  + NULL

#### 2.3、二叉树的运算

+ （1）二叉树的遍历

  + **前序遍历**：先根，再前序遍历左子树，最后前序遍历右子树。

  + **中序遍历**：中序遍历访问左子树，再访问根结点，最后遍历访问右子树。

  + **后序遍历**：后序访问左子树，后序访问右子树，最后访问根结点。

    + ```cpp
      void postorder(btree *p)
      {
          if(p!=NULL)
          {
              postorder(p->left);
              postorder(p->right);
              printf("%d",p->data);
          }
      }
      ```

    + NULL

+ （2）输出二叉树

  + 先输出根结点，然后再依次输出它的左子树和右子树，输出左子树之前要打印出左括号，输出右子树之后要打印出右括号。依次输出的左、右子树要至少有一个不为空。

+ （3）求二叉树的深度

  + 二叉树为空，则深度为0`depth(b)=0`；否则其深度等于左子树或右子树的最大深度加1`depth(b)=max(depth(b->left,b->right)) + 1`。

  + ```cpp
    int depth(btree *b)
    {
        int dep1,dep2;
        if(b == NULL)
            return (0);
        else
        {
            dep1 = depth(b->left);
            dep2 = depth(b->right);
            if(dep1 > dep2)
                return (dep1 + 1);
            else
                return (dep2 + 1);
        }
    }
    ```

  + NULL

### 3、二叉排序树

#### 3.1、二叉排序树的定义

#### 3.2、二叉排序树的查找

#### 3.3、二叉排序树的生成

#### 3.4、二叉排序树的删除

### 4、树和森林

#### 4.1、树的存储

+ 以树的存储**孩子兄弟表示法**。

#### 4.2、森林和二叉树的转换

+ （1）森林转换成二叉树
  + 若森林F不为空，则B的根root即森林中的第一棵树的根；B的左子树LB是从T1中根结点的子树森林F1=
+ （2）二叉树转换为森林
  + `B={root,LB,RB}`是为非空；森林中的第一棵树T1的根即为二叉树B的根root；森林T1中根结点的子树森林F1是由B的左子树LB转换而成森林，森林F中除T1之外其余树组成的森林F'={T2,T3,......Tm}是由B的右子树RB转换而成的森林。

### 5、Huffman树

#### 5.1、基本术语

+ **路径**：若在一棵树中存在着一个结点序列k1,k2,...,kj，使得ki是ki+1的父亲（1<=i<j），则称该结点序列是从k1到kj的**路径**。
+ **路径长度**：接上，从k1到kj所经过的分支数称为这两点之间的**路径长度**。
+ **结点的权**：树中的结点上赋予的一定意义的实数。
+ **带权路径长度**：从树根结点到该结点之间的路径长度与该结点上权的乘积。
+ **树的带权路径长度（WPL）**：树中所有叶子结点的带权路径长度之和。
+ **Huffman树（最优二叉树）**：它是n个带权叶子结点构成的所有二叉树中，带权路径长度WPL最小的二叉树。

#### 5.2、构造Huffman树

+ *这个写得有点晦涩*，看图就能秒懂。

#### 5.3、Huffman（哈夫曼）编码

+ 一段电文“CAST&TAT&A&SA”，统计电文中字母的频度f('C')=1,f('S')=2,f('T')=3,f('&')=3,f('A')=4。用频度{1,2,3,3,4}为权值生成Huffman树，并在每个叶子上注明对应的字符。
  + 指向左子树根的分支表示“0”码，指向右子树的分支表示“1”码，取每条路径上的“0”或“1”的序列作为和各个叶子对应的字符的编码，就是**Huffman编码**。

## ReadMe

+ 20200621花了2h读了这章内容，20200622整理，不过有些点还是没看完。
  + 线索二叉树：没太坚持看完呢。【自考的真题完全没感觉】
  + 二叉树的遍历：看完了，有点感觉。【自考的真题还不能完全做对】
    + *递归转化为栈的方式*，这个也不太熟。
  + *二叉排序树*相关的不太熟。
  + 树和森林的转换，不太熟
  + Huffman树，不确定能不能做对题呢