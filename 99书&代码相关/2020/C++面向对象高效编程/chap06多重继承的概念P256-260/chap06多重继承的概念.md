## chap06、多重继承的概念

+ 大多数设计方案并不需要多重继承（MI）。

### 6.1、多重继承的简单定义

### 6.2、大学例子

+ 研究生类TGraduateStudent

#### 6.2.1、改进后的代码重用

+ `class TGradTeachingAsst : public TGraduateStuent, public TTeacher{// class member functions and data members}` **不写public，默认就是private**。

### 6.3、多重继承关系的含义

+ 在TGradTEachingAsst和所有其他直接和间接基类必须可以应用多态置换原则。（我们应该可以用TRradTeachingAsst替换TPerson，TStudent，TGraduateStudent和TTeacher，而行为不会发生变化。任何时候，TRradTeachingAsst对象都是一个TPerson，TStudent，TGraduateStudent和TTeacher。）
+ **MI标志着派生类（至少）具有它的所有基类（可能更多）行为的组合**。

### 6.4、MI情况

+ 多次继承方法--名称冲突

#### 6.4.1、C++中解决名称冲突

+ **要密切注意从基类中继承的成员函数，并为每个从多个基类继承的方法提供实现**。

#### 6.4.2、二义性基类问题

### 6.5、多重继承的基本优点

+ （1）我们完全可以重用两个（或者更多）不同类中的实现，并用不多的代码创建一个新类。
+ （2）MI也有助于对多种关系组合进行建模
+ （3）多重继承可以导致更大程度的代码重用

### 6.6、多重继承的替换方法

#### 6.6.1、第一种替换方法

#### 6.6.2、第二种情况

### 6.7、重复继承

### 6.8、重复继承的解决方案

#### 6.8.1、在C++中利用虚基类共享对象

#### 6.8.2、虚基类的优点

#### 6.8.3、虚基类产生的新问题

+ **所有虚基类都由最后的派生类的构造函数所初始化。当创建一个完整的对象的时候，将忽略子对象构造函数内部对虚基类构造函数的现存调用**。

#### 6.8.4、比较Eiffel和C++中的MI

### 6.9、继承的一般问题

+ 继承是静态关系，这意味着它不是易于修改的关系，它缺乏灵活性。

### 6.10、使用MIXIN类加入静态功能

#### 6.10.1、Mixin类的定义

#### 6.10.2、何时使用Mixin类

### 6.11、动态变化情况的设计

#### 6.11.1、角色扮演类的设计灵活性

#### 6.11.2、使用角色扮演类

#### 6.11.3、管理角色的另一种方法

#### 6.11.4、TUniversityMember对象的多态用法

#### 6.11.5、对现存类的必须改动

#### 6.11.6、Mixin类和角色对象的比较--适用性

### 6.12、C++的私有派生

#### 6.12.1、何时使用私有派生

#### 6.12.2、重新导出私有基类的成员

#### 6.12.3、私有派生的替换方法--包含

#### 6.12.4、私有派生的需求

### 6.13、mixin类和私有派生的实用示例

### 6.14、继承和包含

+ 通过覆盖基类的成员函数，使得派生类在需要的时候可以很容易地定制它们的行为。
+ 继承引入了基类和派生类之间的永久绑定。

### 6.15、小结

## ReadMe

+ 20200617上午初步过了一下。