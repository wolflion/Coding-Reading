## chap03：C++与数据抽象

### 3.1、类概念基础

+ 类的一些重要特征：
  + 访问属性private，protected，public
  + 静态和非静态成员函数的原型以及数据成员的声明
  + 可以包含其中的另一个类（嵌套类）的声明
+ TIntStack类的示例

```cpp
class TIntStack{
public:
    //Member Functions
    //Default Constructor
    TIntStack(unsigned int stackSize = DEFAULT_SIZE);
    TIntStack(const TIntStack& that); //copy constructor
    //Assignment Operator
    TIntStack& operator=(const TIntStack& assign);
    ~TIntStack();//Destructor
    void Push(int thisValue);
    int Pop();
    unsigned int HowMany() const;
    //add many more member functions
private:
    //Data Members
    int* _sp;
    unsigned _count;
    unsigned _size;
};
```

### 3.2、类元素细节

#### 3.2.1、访问区域

+ public区域仅仅看见成员函数。

#### 3.2.2、分析

### 3.3、复制构造函数

+ `Tingstack s2=s1;`//因为非内置类型需要复制构造函数，不能跟`int i=j;`
+ 复制构造函数的声明：`TIntStack(TIntStack& source)`

```cpp
int j;
int k(j); //This is as good as int k = j;
char*p("ABCD"); //as good as char*p = "ABCD";
```

#### 3.3.1、访问对象的数据成员--C++模型

### 3.4、赋值运算符

+ `a = b;//Assign one stack to another`
+ 对于任何赋值运算符，必须注意几件事情：
  + （1）确保我们没有将对象赋给它本身（如a=a）
  + （2）重新使用被赋值对象中的资源或删除它
  + （3）从源对象上复制任何需要复制的东西到目的对象
  + （4）最后，返回对目的对象的引用

### 3.5、this指针和名称修正的进一步说明

### 3.6、const成员函数的概念

### 3.7、编译器实现const成员函数的方式

+ 数据成员和函数之间的唯一链接就是this指针。
+ const成员函数必须将对象作为const对象，这可以通过将this指针表明为指向const的指针而轻松地做到。
+ const成员函数并不能在它的实现中调用另一个非const成员函数，因为非const成员函数会在相同的对象上调用（相同的this指针），它可以随意修改对象。

### 3.8 C++中类和结构的区别

+ 默认情况下，类中所有的东西都是私有的，而在结构中，所有东西都是公共的。

``` cpp
class X{    
    int a; //This is a private data member
    void f(); // This is private member function
};
```
### 3.9 类可以包含什么

+ C++下，类可以包含
	+ 原始类型的数据成员（如int,char）
	+ 另一个类的对象
	+ 另一个类（或相同类）的指针或引用
	+ 指向原始类型的指针或引用
+ 代码例子

### 3.10 设计期间的重点--类的接口

+ 如果只是利用类创建一个对象，**将注意public区域**。
+ 如果利用继承从类创建一个新类，**将注意力转向类的public及protected区域**。
+ 仅仅通过名称可能很难理解（和使用）某个按钮，这就需要用户手册了。

### 3.11 类名、成员函数名、参数类型和文档

+ 为类和其中所包含的方法提供一个有意义的名称。也必须为成员函数的参数提供有描述性的名称。
+ 良好的文档，内容
	+ 类的用途
	+ 预定用户
	+ 它所依赖的类（如果有）
	+ 使用类的限制
	+ 它期望从客户得到什么

### 3.12 参数传递模式--客户的视图

+ 参数可以按值，按引用，按指针传递。它们可以和const关联使用，以让它们更加可靠。
+ ``

### 3.13 采用语义

+ （6）`void X::f(const T* argp)//Second pointer example` 这种模式不能在采用语义中使用（至少不能不进行类型就使用），因为指向const的指针无法删除。

### 3.14 为参数选择正确的模式

+ 如果可能，避免按值传递大型对象。对于简单的和小型对象，可按值传递。**复制对象的代价是很昂贵的**。
+ 当希望传递对象的时候，不要传递指针。`void f(T* object);`
	+ （1）指针并不能保证它胡实是指向对象的指针，它很可能是一个空指针。

### 3.15 函数返回值

+ 许多函数向调用者返回某些东西。返回的东西可以是值、引用或者指针。
+ 代码

```cpp
a
```

+ 可能的模式
	+ （1）永远不要返回对局部变量的引用（指针）。

### 3.16 从函数中返回引用

+ **要尽可能避免从函数返回引用**，以下几个原因：
	+ （1）当对象的引用（假定为foo）可以从函数安全返回时，函数可能不应该创建对象foo。
	+ （2）

### 3.17 编写内存安全类

#### 3.17.1 改善性能

+ **在编写类的第1个版本的时候，并不要把注意力都集中在性能上。第一个和首要目标是正确实现类**。

### 3.18 客户对类和函数的责任

+ （1）理解类的用途
+ （2）明确理解类的实现者希望从客户那里得到什么。在客户和实现者之间有一个协议。
+ （3）注意每个成员函数，特别是const成员函数--它们比较安全。

### 3.19 小结

+ 要理解当你不提供它的时候，编译器所产生的东西。
+ 不要在函数声明中忽略参数名称。每个参数名称都必须明确向客户表示它的用途。
+ 理解客户对函数参数模式和返回值的视图。使用合适的参数传递模式，并在所有代码中保持一致的样式。力图避免从函数返回非const指针。
+ 说明每个类的用途和预期用户。为每个成员函数提供有意义的文档说明。

## ReadMe

+ 20200508-0509电子版看了一遍，效率比纸质书还高点嘛，**get到了类中函数的设计（何时用引用、指针、const之类的）**，以前好像都没有意识去考虑这些问题啊。