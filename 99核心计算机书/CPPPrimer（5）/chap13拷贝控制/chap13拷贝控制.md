## chap13拷贝控制

### 13.1、拷贝、赋值与销毁

#### 13.1.1、拷贝构造函数

+ 构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是**拷贝构造函数**。

```cpp
class Foo{
    public:
    Foo();            //默认构造函数
    Foo(const Foo&);  //拷贝构造函数
}
```

+ **合成拷贝构造函数**
+ 拷贝初始化
  + 拷贝初始化通常使用拷贝构造函数来完成。如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数完成。
+ 参数和返回值
  + 拷贝构造函数被用来初始化非引用类类型参数。
+ 拷贝初始化的限制
+ 编译器可以绕过拷贝构造函数

```cpp
string null_book = "9-999-99999-9"; //拷贝初始化
string null_book("9-999-99999-9");//编译器略过了拷贝构造函数
```

#### 13.1.2、拷贝赋值运算符

+ 与拷贝构造函数一样，如果类未定义自已的拷贝赋值运算符，编译器会为它合成一个。
+ 重载赋值运算符
  + 赋值运算符就是一个名为`operator=`的函数，也有一个返回类型和一个参数列表
+ 合成拷贝赋值运算符

#### 13.1.3、析构函数

+ **由于析构函数不接受参数**，因此它不能被重载。对一个给定类，只会有唯一析构函数。
+ 析构函数完成什么工作
+ 什么时候会调用析构函数
+ 合成析构函数

#### 13.1.4、三/五法则

+ 需要析构函数的类也需要拷贝和赋值操作
+ 需要拷贝操作类的也需要赋值，反之亦然

#### 13.1.5、使用=default

+ 将拷贝控制成员定义为`=default`来显式地要求编译器生成合成的版本

```cpp
class Sales_data{
public:
    //拷贝控制成员；使用default
    Sales_data() = default;
    Sales_data(const Sales_data&) = default;
    Sales_data& operator=(const Sales_data &);
    ~Sales_data() = default;
    //其它成员的定义，如前
};

Sales_data& Sales_data::operator=(const Sales_data&) = default;
```

#### 13.1.6、阻止拷贝

+ 定义删除的函数（用`=delete`）
+ 析构函数不能是删除的成员
+ 合成的拷贝控制成员可能是删除的
+ private拷贝控制

### 13.2、拷贝控制和资源管理

#### 13.2.1、行为像值的类

+ 类值拷贝赋值运算符

#### 13.2.2、定义行为像指针的

+ 引用计数
+ 定义一个使用引用计数的类
+ 类指针的拷贝成员“篡改”引用计数

### 13.3、交换操作

+ 编写我们自已的swap函数
+ swap函数应该调用swap，而不是std::swap
+ 在赋值运算符中使用swap

### 13.4、拷贝控制示例

+ Message类
+ save和remove成员
+ Message类的拷贝控制成员

### 13.5、动态内存管理类

+ StrVec类的设计

### 13.6、对象移动

+ **IO类或unique_ptr这样的类，都包含不能被共享的资源（如指针或IO缓冲）**，因此，这些类型的对象不能拷贝但可以移动。

#### 13.6.1、右值引用

+ **右值引用**：就是必须绑定到右值的引用。通过`&&`来获得右值引用。
+ 右值引用有一个重要的性质---**只能绑定到一个将要销毁的对象**。

```cpp
int i = 42;
int &r = i;  //true，r引用i
int &&rr = i;//error，不能将一个右值引用绑定到一个左值上
int &r2 = i*42; //error，i*42是一个右值
const int &r3 = i*42;   //正确，我们可以将一个const的引用绑定到一个右值上
int &&rr2 = i*42;  //true，将rr2绑定到乘法结果上
```



+ 左值持久，右值短暂
+ 变量是左值

```cpp
int &&rr1 = 42; // true，字面常量是右值
int &&rr2 = rr1;//error：表达式rr1是左值
```



+ 标准库move函数
  + `int &&rr1 = 42; int &&rr3=std::move(rr1);//ok`  **move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。**
  + 调用move就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。

#### 13.6.2、移动构造函数

+ 移动迭代器

#### 13.6.3、右值引用和成员

+ 右值和左值引用成员函数
  + **引用限定符可以是`&`或`&&`，分别指出this可以指向一个左值或右值**。
+ 重载和引用函数

## ReadMe

+ 20200507看第1版，没有太多感觉啊，C++11的知识有点多，后面再来看第2遍吧。