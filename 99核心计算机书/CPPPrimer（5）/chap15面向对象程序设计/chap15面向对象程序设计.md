## chap15、面向对象程序设计   525（551/864）

### 15.1、OOP：概述

+ 面向对象程序设计的核心思想：**数据抽象、继承和动态绑定**。

  + 通过使用数据抽象，我们可以将类的接口与实现分离；
  + 使用继承，可以定义相似的类型并对其相似关系建模
  + 使用动态绑定，可以在一定程度上忽略相信类型的区别，而以统一的方式使用它们的对象

+ 继承

  + 对于某些函数，**基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为虚函数（virtual function）**。
  + 派生类：派生类列表（class derivation list）

  ```cpp
  class Bulk_quote:public Quote{//Bulk_quote继承了Quote
  public:
      double net_price(std::size_t) const override;
  };
  ```

  + **派生类必须在其内部对所有重新定义的虚函数进行声明**。派生类可以加`virtual`关键字，也可以不加。**C++11允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，在该函数的形参列表之后增加一个override关键字**。

+ 动态绑定
  + **在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定**。
  + 以下函数：传的是基类Quote的引用

```cpp
double print_total(ostream &os, const Quote &item, size_t n)
{
    //根据传入item形参的对象类型调用Quote::net_price
    //或者Bulk_quote::net_price
    double ret = item.net_price(n);
    os << "ISBN: "<<item.isbn() //调用Quote::isbn
        << " # sold: "<< n << "total due: "<< ret <<endl;
    return ret;
}
```

### 15.2、定义基类和派生类  527（553/864）

#### 15.2.1、定义基类

+ Quote类的定义

```cpp
class Quote{
public:
    Quote() = default;  //关于=default请参见7.1.4节
    Quote(const std::string &book, double sales_price):bookNo(book),price(sales_price){}
    std::string isbn() const {return bookNo;}
    //返回给定数量的书籍的销售总额
    //派生类负责改写并使用不同的折扣计算算法
    virtual double net_price(std::size_t n)const {return n*price;}
    virtual ~Quote() = default;  //对析构函数进行动态绑定
private:
    std::string bookNo;  //书籍的ISBN编号
protected:
    double price = 0.0;//代表普通状态下不打折的价格
};
```

+ 成员函数与继承
  + 派生类需要对这些操作提供自已的新定义以**覆盖（overrid）**从基类继承而来的旧定义。
  + （1）基类希望其派生类进行覆盖的函数，**定义为虚函数**
  + （2）基类希望派生类直接继承而不要改变的函数
+ 访问控制与继承

#### 15.2.2、定义派生类

+ 使用**派生类列表**
+ 派生类中的虚函数
+ 派生类对象及派生类向基类的类型转换
+ 派生类构造函数
+ 派生类使用基类的成员
+ 继承与静态成员
+ 派生类的声明
+ 被用作基类的类
+ 防止继承的发生

#### 15.2.3、类型转换与继承

+ **当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型**。该对象可能是基类的对象，也可能是派生类的对象。

+ 静态类型与动态类型
+ 不存在从基类向派生类的隐式类型转换......
+ ......在对象之间不存在类型转换
+ **关键概念**：存在继承关系的类型之间的转换规则
  + （1）从派生类向基类的类型转换只对指针或引用类型有效
  + （2）基类向派生类不存在隐式类型转换
  + （3）和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。

### 15.3、虚函数  536（562/864）

+ 通常情况下，如果我们不使用某个函数，则无须为该函数提供定义。但是我们**必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数**。
+ 对虚函数的调用可能在运行时才被解析
+ **关键概念：C++的多态性**
+ 派生类中的虚函数
  + **一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数**。
+ final和override说明符
+ 虚函数与默认实参
+ 回避虚函数的机制

### 15.4、抽象基类  540（566/864）

+ 纯虚函数
+ 含有纯虚函数的类是抽象基类
  + **抽象基类负责定义接口，而后续的其他类可以覆盖其接口。我们不能（直接）创建一个抽象基类的对象**。
+ 派生类构造函数只初始化它的直接基类
+ **关键概念：重构**

### 15.5、访问控制与继承

### 15.6、继承中的类作用域

### 15.7、构造函数与拷贝控制

### 15.8、容器与继承

### 15.9、文本查询程序再探