## chap12、动态内存  399（425/864）

### 12.1、动态内存和智能指针 400（426/864）

#### 12.1.1、shared_ptr类

+ 创建智能指针时，必须提供额外的信息--**指针可以指向的类型**。
  + `shared_ptr<string> p1;//shared_ptr，可以指向string`
  + `shared_ptr<list<int>> p2;//shared_ptr，可以指向int的list`
+ 检查一个智能指针非空，以及指向的值。
  + `if(p1 && p1->empty()) {*p1 = "hi"}//p1不为空，检查它是否指向一个空string，指向空了，解引用p1，将一个新值赋予string`
+ shared_ptr支持的操作
+ make_shared函数

#### 12.1.2、直接管理内存

+ 自已直接管理内存的类（new和delete）与使用智能指针的类不同，**它们不能依赖对象拷贝、赋值和销毁操作的任何默认定义**。
+ 使用new动态分配和初始化对象
  + `string *ps = new string;//初始化为空string`
  + `int *pi = new int;//pi指向一个未初始化的int`
+ 动态分配的const对象
  + `const int *pci = new const int(1024); //分配并初始化一个const int`
+ 内存耗尽
  + 分配失败判断。头文件new
+ 释放动态内存
  + **delete表达式接受一个指针，指向我们想要释放的对象**。
    + `delete p;//p必须指向一个动态分配的对象或是一个空指针`
  + delete表达式也执行两个动作：**销毁给定的指针指向的对象；释放对应的内存**。
+ 指针值和delete
  + **释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的**。
+ 动态对象的生存期直到被释放时为止
+ **小心：动态内存的管理非常容易出错**
  + 1、忘记delete内存
  + 2、使用已经释放掉的对象
  + 3、同一块内存释放两次
+ delete之后重置指针值......
+ ......这只是提供了有限的保护

#### 12.1.3、shared_ptr和new结合使用

+ **如果我们不初始化一个智能指针，它会被初始化为一个空指针**。
  + `shared_ptr<int> p2(new int(42));//p2指向一个值为42的int`
+ **不要混合使用普通指针和智能指针......**
+ ......也不要使用get初始化另一个智能指针或为智能指针赋值

```cpp
shared_ptr<int> p (new int(42)); //引用计数为1
int *q = p.get(); //正确：但使用q时要注意，不要让它管理的指针被释放
{
    //新程序块
    //未定义：两个独立的shared_ptr指向相同的内存
}
```

+ 其它shared_ptr操作

#### 12.1.4、智能指针和异常

+ 智能指针和哑类
+ 使用我们自已的释放操作
+ **注意：智能指针陷阱**

#### 12.1.5、unique_ptr

+ **一个unique_ptr拥有它指向的对象**，因此unique_ptr不支持普通的拷贝或赋值操作。
+ 传递unique_ptr参数和返回unique_ptr
  + 我们可以拷贝或赋值一个将要被销毁的unique_ptr
+ **向后兼容auto_ptr**，但不建议用
+ 向unique_ptr传递删除器

#### 12.1.6、weak_ptr

+ weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。
+ 当我们创建一个weak_ptr时，要用一个shared_ptr来初始它：
  + **由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须访问lock**。

```cpp
auto p = make_shared<int>(42);
weak_ptr<int> wp(p); //wp弱共享p；p的引用计数未改变		
```

+ 核查指针类
+ 指针操作

### 12.2、动态数组  423（449/864）

+ 标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。

#### 12.2.1、new和数组

+ `int *pia = new int[get_size()]; //pia指向第1个int`
+ 分配一个数组会得到一个元素类型的指针
+ 初始化动态分配对象的数组
+ 动态分配一个空数组是合法的
+ 释放动态数组
+ 智能指针和动态数组

#### 12.2.2、allocator类

+ allocator类
  + 标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。
+ allocator分配未构造的内存
+ 拷贝和填充未初始化内存的算法

### 12.3、 使用标准库：文本查询程序  430（）

### 小结（）