## 02、并发基本概念及实现，进程线程基本概念

### 2.1、并发、进程、线程的基本概念和综述

#### 2.1.1、并发

+ 两个或者更多的任务（独立的活动）同时发生（进行）。*一个程序同时执行多个独立的任务*。
+ 单核CPU，某一时刻（同一时刻）只能执行一个任务
  + 由操作系统调度，每秒钟进行多次所谓的“任务切换”
  + *这不是真正的并发，是通过切换来的假象*，这个切换也叫（上下文切换）。这种切换是有时间开销，同时要保存中间状态。
+ 多处理器计算机：用于服务器和高性能计算领域。
+ 现在的台式机，在一块芯片上有多核（多个）CPU，双核，4核。能够实现真正的并行执行多个任务（**硬件并发**）。
+ 使用并发的原因：主要就是同时可以干多个事，提高性能。

#### 2.1.2、可执行程序

+ 磁盘上的文件（.exe）

#### 2.1.3、进程

+ 进程：就是一个可执行程序运行起来了，就叫创建了一个进程。

#### 2.1.4、线程

+ 每个进程，都有唯一的主线程。**也就是一个进程中，只能有一个主线程**。
+ 当你执行可执行程序，产生了一个进程后，这个主线程就随着这个进程默默地启动起来了。【**实际上是进程的主线程在调用main函数中的代码**】
+ 主线程和进程唇齿相依，有你必然有我，有我必然有你，没有我必然没有你。
+ **线程：执行代码**。
+ 线程这个东西，可以（理解成一条代码的执行通路，从上到下执行完，就结束）。
+ 除了主线程之外，我们可以通过自己写代码来创建其它线程，其它线程走的是别的道路，就是调用其它的函数（main只给主线程走）。【同时走，就叫 并发】
+ 每创建一个新线程，我就可以在同一个时刻，多干一个不同的事（多走一条不同的代码执行路径）。
+ 多线程（并发）线程并不多越多越好，每个线程都需要独立堆栈空间（1M），线程的上下文切换是有代价的。【切换会耗费该属于程序运行的时间】
+ 总结线程：
  + a、线程是用来执行代码的
  + b、把线程这个东西理解成一条代码的执行通路（道路），一个新线程代表一个新的通路。
  + c、一个进程自动包含一个主线程，主线程随着进程默默的启动并运行，我们可以通过编码来创建多个其它线程（非主线程），但是创建的数量最大都不建议200-300个。
  + d、因为主线程是自动启动的，所以一个进程中最少也是有一个线程（就是主线程）。进程和主线程感觉是爹和儿子的关系。
  + e、说白了：多线程程序可以同时干多个事，所以运行效率高，但到底有多高，并不是一个很容易评估和量化的东西。【访问的资源是独立的，效率就高；访问互斥资源，就得看情况】

#### 2.1.5、学习心得

+ 开发多线程程序一个是实力的体现；一个是商用的必须需要。
+ 线程开发有一定难度；实现代码也更复杂；理解上也更难一些，需要一定的学习时间
+ C++线程会涉及很多新概念，对于C++道路上的成长特别关键，不要急于求成；
+ 想拿高薪，网络通讯、网络服务器，多线程是绝对绕不开的，必须得学

### 2.2、并发的实现方法

+ 两个或者更多的任务（独立的活动）同时发生（进行）
+ 实现并发的手段：
  + 我们通过多个进程实现并发
  + 在单独的进程中，我创建多个线程来实现并发  【自己写代码，来创建除了主线程之外的其它线程】

#### 2.2.1、多进程并发

+ 账户服务器、游戏逻辑服务器，这是两个进程。两个进程之间通信。
+ 进程间之间通信（同一个电脑上：**管道，文件，消息队列，共享内存**）；（不同的电脑上：socket）。

#### 2.2.2、多线程并发

+ 单个进程中，创建了多个线程
+ 线程：感觉像轻量级的进程。每个线程都有自己独立的运行路径，但是一个进程的所有线程共享地址空间（共享内存信息）【全局变量，全局指针，全局引用，都可以在线程之间传递】。
+ 所以使用多线程开销，远远小于多进程。
+ **共享内存带来的问题，数据一致性问题**。线程A和线程B，可能会操作同一个变量。

#### 2.2.3、总结

+ **虽然两个都可以混合用**，但老师建议**优先使用多线程**。
+ 在chap6中，只讲解多线程的开发技术。**后续的并发，都是多线程并发**。
+ 和进程比，线程如下优点：
  + 1、线程启动速度更快，更轻量级
  + 2、系统资源开销更少，执行速度更快，比如共享内存的这种通信方式比任何其它的通信方式都快；
+ 缺点：
  + 1、使用起来，有一定难度，要小心处理数据的一致性问题

### 2.3、C++11新标准线程库

+ 以往：windows下：CreateThread(), _beginthread()
+ linux下：pthread_create()，创建线程
+ 临界区、互斥量
+ 以往多线程代码不能跨平台；
+ POSIX thread(pthread)：跨平台的【需要做一些配置，所以用起来也不是那么方便】
+ 从C++11新标准，C++语言本身增加了多线程的支持，而不是通过操作系统的接口来调用。**操作系统无关的多线程，意味着可移植性**。

## ReadMe

+ 20200522看了15min；
+ 20201021又开始看了；