## 07互斥量概念、用法、死锁演示及解决详解

### 7.1、互斥量（mutex）的基本概念

+ **互斥量**就是一个类对象，理解为一把锁。多个线程尝试用lock()成员函数来尝试加锁，**只有一个线程能锁成功（有返回，才表示锁成功）；锁不成功，就一直卡在那**。
+ 互斥量使用要小心，保护数据不多不少，**少了，没达到保护效果；多了，影响效率**。

### 7.2、互斥量的用法

+ `<mutex>`头文件

#### 7.2.1、lock()，unlock()

+ 先lock()，操作共享数据，unlock()。**所有线程都这么做，但只有一个会lock住**。
+ lock()和unlock()要成对使用，有lock()必然要调用一次unlock()。**不允许不成对，或非对称数量调用，会导致不稳定和崩溃**。
+ **最好把加锁的代码抽象出来**。

#### 7.2.2、std::lock_guard类模板

### 7.3、死锁

#### 7.3.1、死锁演示

#### 7.3.2、死锁的一般解决方案

#### 7.3.3、std::lock的函数模板

#### 7.3.4、std::lock_guard的std::adopt_lock参数