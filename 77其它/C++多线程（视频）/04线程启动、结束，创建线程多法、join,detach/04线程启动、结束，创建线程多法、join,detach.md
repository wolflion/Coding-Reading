## 04、线程启动、结束，创建线程多法、join,detach



### 4.1、 范例演示线程运行的开始和结束

+ 主线程从main()开始执行，我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，就代表着我们这个线程，运行结束。
+ 整个进程是否执行完毕的标志是，主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了。一般情况下：如果其它子线程还没有执行完毕，那么这些子线程也会被操作系统强行终止。
+ a、包含thread头文件；
+ b、在main之前创建一个函数 【也叫初始函数】
+ c、main中开始写代码
+ 有2个线程在跑，相当于整个程序执行有2条线在走，所以 ，可以同时干两个事，即使一条线被堵住了，也不影响另一条线的执行。

#### 4.1.1、thread

+ `thread mythreadobj(myprint);  // thread是标准类里的类   ` 【myprint是**可调用对象**】
  + 创建了线程，线程执行的起点（入口）是myprint，这个函数开始执行。

#### 4.1.2、join()

+ 加入，汇合。**阻塞主线程，让主线程等待子线程执行完毕，子线程和主线程会和，然后主线程再往下走**。
+ `mythreadobj.join();`//让主线程等子进程执行完毕  【当子线程执行完毕，主线程再往下走】
+ *尝试在IDE上注释掉`join()`一行，再看结果，同时再单步调试看下具体的值*。 【这时会有异常，因为主线程可能会先于子线程先退出】
+ **如果主线程执行完毕，子线程没执行完毕，程序员写这个程序，是不合格的，程序也是不稳定的**。

#### 4.1.3、detach()

+ **凡事皆有例外**，传统的多线程时，主线程要等子线程执行完毕才能结束。detach（**分离**）主线程可以先退出。
+ detach：主线程不跟子线程会合，各自执行各自的函数，主线程也不必等子线程结束。
+ Q1：为什么要引入detach()
  + 我们创建了很多子线程，让主线程逐个等待子线程结束，这种编程方法不太好，所以引入了detach()。
+ 一旦detach之后，与主线程关联的thread对象就会失去与这个主线程的关联，此时子线程就会驻留在后台运行。【**这个子线程就相当于被C++运行时库接管，当这个子线程执行完成后，由运行时库负责清理该相关的资源**（守护线程）】
  + `mythread.detach()`
+ detach()使线程myprint失去我们自己的控制，**老师更推荐join**（如果干的活与主线程没啥关系，可以用detach）。
+ 一旦调用了detach()，就不能再用join()回来了，否则系统会报告异常。

#### 4.1.4、joinable()

+ 判断是否可以成功使用join()或者detach()的；返回true【可以join()或detach()】或false
+ `if(mythreadobj.joinable()) {cout<<"can join"<<endl;}`
+ **join()或detach()之后，不能再join()或detach()**，否则程序会有异常。

### 4.2、其他创建线程的手法

+ 函数是可调用对象；类也可以作为可调用对象，但要重载()

#### 4.2.1、用类，以及一个问题范例

+ ```cpp
  class TA
  {
      public:
         void operator() () //不带参数
         {
             cout<<"operator start"<<endl;
         }
  };
  
  TA ta;
  thread mythreadobj(ta);  // ta是个可调用对象
  mythreadobj.join(); // 等待子线程输出结束
  ```

+ detach()的一些坑

  + 主线程的结束后，`m_i`的变量被销毁了，所以子进程没有打印出来。
  + **一旦调用了detach()，那我主线程执行结束了，我这里用的ta这个对象还在吗？**【肯定不在了】
  + **这个ta对象实际上是被 复制 到线程中去的**，所以执行完主线程后，ta会被销毁，但是所复制的ta对象依旧存在。**所以，只在TA类对象里没有引用，没有指针，那么就不会产生问题**。

#### 4.2.2、用lambda表达式

## ReadMe

+ 20201022中午和晚上看了部分；
+ 20201023中午和晚上全部看完。
+ **detach**里面的一些坑，尤其是**类的方式创建，用的是指针、引用**时，会存在释放的问题。